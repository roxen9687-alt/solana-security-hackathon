{
  "program_id": "7M8t8PJSZeR9ZLH1Fk7wEKkTxXfQqzz4jtgjwrKKKnNT",
  "total_exploits": 102,
  "critical_count": 13,
  "high_count": 52,
  "medium_count": 27,
  "exploits": [
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_swap_with_protection",
      "line_number": 19,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Missing Slippage Protection",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-033",
      "cwe": "CWE-20",
      "instruction": "handle_swap_with_protection",
      "line_number": 19,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Swap operation without slippage protection.",
      "attack_scenario": "MEV bots sandwich the transaction for profit.",
      "secure_fix": "Add min_amount_out parameter and validate",
      "prevention": "Always implement slippage tolerance",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "MEV bots sandwich the transaction for profit."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Swap operation without slippage protection.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Swap operation without slippage protection.",
      "attack_scenario_enhanced": "MEV bots sandwich the transaction for profit.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Swap operation without slippage protection."
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "handle_swap_with_protection",
      "line_number": 19,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "No emergency pause mechanism.",
      "attack_scenario_enhanced": "Cannot stop exploit in progress.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: No emergency pause mechanism."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_initialize_pool",
      "line_number": 35,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "handle_initialize_pool",
      "line_number": 35,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Account can be reinitialized, allowing state reset.",
      "attack_scenario_enhanced": "Attacker reinitializes account to reset state and steal funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Account can be reinitialized, allowing state reset."
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Stale Oracle Data",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-020",
      "cwe": "CWE-672",
      "instruction": "handle_initialize_pool",
      "line_number": 35,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Oracle data freshness not validated.",
      "attack_scenario": "Stale price data used for trading decisions.",
      "secure_fix": "Check oracle.last_update_timestamp against current slot",
      "prevention": "Reject prices older than acceptable threshold",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Stale price data used for trading decisions."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Oracle data freshness not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Oracle data freshness not validated.",
      "attack_scenario_enhanced": "Stale price data used for trading decisions.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Oracle data freshness not validated."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "verify_transfer_amount",
      "line_number": 39,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Token Program Validation",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-024",
      "cwe": "CWE-345",
      "instruction": "verify_transfer_amount",
      "line_number": 39,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token program not validated.",
      "attack_scenario": "Attacker passes fake token program.",
      "secure_fix": "Use Program<'info, Token> to validate program ID",
      "prevention": "Always validate program accounts in CPI",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker passes fake token program."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token program not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Token program not validated.",
      "attack_scenario_enhanced": "Attacker passes fake token program.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Token program not validated."
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "verify_transfer_amount",
      "line_number": 39,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "State changes not logged.",
      "attack_scenario_enhanced": "Cannot track or audit protocol activity.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: State changes not logged."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "swap_with_protection",
      "line_number": 58,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Missing Slippage Protection",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-033",
      "cwe": "CWE-20",
      "instruction": "swap_with_protection",
      "line_number": 58,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Swap operation without slippage protection.",
      "attack_scenario": "MEV bots sandwich the transaction for profit.",
      "secure_fix": "Add min_amount_out parameter and validate",
      "prevention": "Always implement slippage tolerance",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "MEV bots sandwich the transaction for profit."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Swap operation without slippage protection.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Swap operation without slippage protection.",
      "attack_scenario_enhanced": "MEV bots sandwich the transaction for profit.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Swap operation without slippage protection."
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "swap_with_protection",
      "line_number": 58,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "No emergency pause mechanism.",
      "attack_scenario_enhanced": "Cannot stop exploit in progress.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: No emergency pause mechanism."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "get_secure_price",
      "line_number": 74,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Oracle Price Manipulation",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-019",
      "cwe": "CWE-20",
      "instruction": "get_secure_price",
      "line_number": 74,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Single oracle source without price bounds check.",
      "attack_scenario": "Attacker manipulates oracle price to drain funds.",
      "secure_fix": "Use multiple oracles, TWAP, and price deviation checks",
      "prevention": "Implement circuit breakers for sudden price changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 85,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates oracle price to drain funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 1200000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Single oracle source without price bounds check.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Single oracle source without price bounds check.",
      "attack_scenario_enhanced": "Attacker manipulates oracle price to drain funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Single oracle source without price bounds check."
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Stale Oracle Data",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-020",
      "cwe": "CWE-672",
      "instruction": "get_secure_price",
      "line_number": 74,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Oracle data freshness not validated.",
      "attack_scenario": "Stale price data used for trading decisions.",
      "secure_fix": "Check oracle.last_update_timestamp against current slot",
      "prevention": "Reject prices older than acceptable threshold",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Stale price data used for trading decisions."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Oracle data freshness not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Oracle data freshness not validated.",
      "attack_scenario_enhanced": "Stale price data used for trading decisions.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Oracle data freshness not validated."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "deposit",
      "line_number": 83,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "deposit",
      "line_number": 83,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "No emergency pause mechanism.",
      "attack_scenario_enhanced": "Cannot stop exploit in progress.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: No emergency pause mechanism."
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "deposit",
      "line_number": 83,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "State changes not logged.",
      "attack_scenario_enhanced": "Cannot track or audit protocol activity.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: State changes not logged."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "create_voting_escrow",
      "line_number": 96,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "create_voting_escrow",
      "line_number": 96,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Flash loan without proper repayment validation.",
      "attack_scenario_enhanced": "Attacker manipulates state during flash loan and doesn't repay.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Flash loan without proper repayment validation."
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "initialize_emergency_state",
      "line_number": 108,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Account can be reinitialized, allowing state reset.",
      "attack_scenario_enhanced": "Attacker reinitializes account to reset state and steal funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Account can be reinitialized, allowing state reset."
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "initialize_vault",
      "line_number": 132,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Account can be reinitialized, allowing state reset.",
      "attack_scenario_enhanced": "Attacker reinitializes account to reset state and steal funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Account can be reinitialized, allowing state reset."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "withdraw",
      "line_number": 141,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "withdraw",
      "line_number": 141,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "No emergency pause mechanism.",
      "attack_scenario_enhanced": "Cannot stop exploit in progress.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: No emergency pause mechanism."
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "withdraw",
      "line_number": 141,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "State changes not logged.",
      "attack_scenario_enhanced": "Cannot track or audit protocol activity.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: State changes not logged."
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "initialize_user_shares",
      "line_number": 153,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Account can be reinitialized, allowing state reset.",
      "attack_scenario_enhanced": "Attacker reinitializes account to reset state and steal funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Account can be reinitialized, allowing state reset."
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "initialize_price_state",
      "line_number": 161,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Account can be reinitialized, allowing state reset.",
      "attack_scenario_enhanced": "Attacker reinitializes account to reset state and steal funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Account can be reinitialized, allowing state reset."
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Oracle Price Manipulation",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-019",
      "cwe": "CWE-20",
      "instruction": "initialize_price_state",
      "line_number": 161,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Single oracle source without price bounds check.",
      "attack_scenario": "Attacker manipulates oracle price to drain funds.",
      "secure_fix": "Use multiple oracles, TWAP, and price deviation checks",
      "prevention": "Implement circuit breakers for sudden price changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 85,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates oracle price to drain funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 1200000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Single oracle source without price bounds check.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Single oracle source without price bounds check.",
      "attack_scenario_enhanced": "Attacker manipulates oracle price to drain funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Single oracle source without price bounds check."
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Stale Oracle Data",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-020",
      "cwe": "CWE-672",
      "instruction": "initialize_price_state",
      "line_number": 161,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Oracle data freshness not validated.",
      "attack_scenario": "Stale price data used for trading decisions.",
      "secure_fix": "Check oracle.last_update_timestamp against current slot",
      "prevention": "Reject prices older than acceptable threshold",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Stale price data used for trading decisions."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Oracle data freshness not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Oracle data freshness not validated.",
      "attack_scenario_enhanced": "Stale price data used for trading decisions.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Oracle data freshness not validated."
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Oracle Price Manipulation",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-019",
      "cwe": "CWE-20",
      "instruction": "reset_circuit_breaker",
      "line_number": 170,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Single oracle source without price bounds check.",
      "attack_scenario": "Attacker manipulates oracle price to drain funds.",
      "secure_fix": "Use multiple oracles, TWAP, and price deviation checks",
      "prevention": "Implement circuit breakers for sudden price changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 85,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates oracle price to drain funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 1200000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Single oracle source without price bounds check.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Single oracle source without price bounds check.",
      "attack_scenario_enhanced": "Attacker manipulates oracle price to drain funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Single oracle source without price bounds check."
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Stale Oracle Data",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-020",
      "cwe": "CWE-672",
      "instruction": "reset_circuit_breaker",
      "line_number": 170,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Oracle data freshness not validated.",
      "attack_scenario": "Stale price data used for trading decisions.",
      "secure_fix": "Check oracle.last_update_timestamp against current slot",
      "prevention": "Reject prices older than acceptable threshold",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Stale price data used for trading decisions."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Oracle data freshness not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Oracle data freshness not validated.",
      "attack_scenario_enhanced": "Stale price data used for trading decisions.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Oracle data freshness not validated."
    },
    {
      "category": "Authorization",
      "vulnerability_type": "Missing Access Control",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-047",
      "cwe": "CWE-862",
      "instruction": "reset_circuit_breaker",
      "line_number": 170,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State modification without access control.",
      "attack_scenario": "Anyone can modify protected state.",
      "secure_fix": "Validate caller is authorized signer",
      "prevention": "Always check authorization before state changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Anyone can modify protected state."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State modification without access control.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "State modification without access control.",
      "attack_scenario_enhanced": "Anyone can modify protected state.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: State modification without access control."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "initialize_pool",
      "line_number": 177,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "initialize_pool",
      "line_number": 177,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Account can be reinitialized, allowing state reset.",
      "attack_scenario_enhanced": "Attacker reinitializes account to reset state and steal funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Account can be reinitialized, allowing state reset."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "vote_on_proposal",
      "line_number": 188,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "vote_on_proposal",
      "line_number": 188,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Flash loan without proper repayment validation.",
      "attack_scenario_enhanced": "Attacker manipulates state during flash loan and doesn't repay.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Flash loan without proper repayment validation."
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "vote_on_proposal",
      "line_number": 188,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Governance lacks required safeguards.",
      "attack_scenario_enhanced": "Flash loan governance attack.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Governance lacks required safeguards."
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "extend_lock",
      "line_number": 198,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Flash loan without proper repayment validation.",
      "attack_scenario_enhanced": "Attacker manipulates state during flash loan and doesn't repay.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Flash loan without proper repayment validation."
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "withdraw_from_escrow",
      "line_number": 206,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Flash loan without proper repayment validation.",
      "attack_scenario_enhanced": "Attacker manipulates state during flash loan and doesn't repay.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Flash loan without proper repayment validation."
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "withdraw_from_escrow",
      "line_number": 206,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "No emergency pause mechanism.",
      "attack_scenario_enhanced": "Cannot stop exploit in progress.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: No emergency pause mechanism."
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "withdraw_from_escrow",
      "line_number": 206,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "State changes not logged.",
      "attack_scenario_enhanced": "Cannot track or audit protocol activity.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: State changes not logged."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "create_proposal",
      "line_number": 213,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "create_proposal",
      "line_number": 213,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Flash loan without proper repayment validation.",
      "attack_scenario_enhanced": "Attacker manipulates state during flash loan and doesn't repay.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Flash loan without proper repayment validation."
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "create_proposal",
      "line_number": 213,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Governance lacks required safeguards.",
      "attack_scenario_enhanced": "Flash loan governance attack.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Governance lacks required safeguards."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "execute_proposal",
      "line_number": 224,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "execute_proposal",
      "line_number": 224,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Flash loan without proper repayment validation.",
      "attack_scenario_enhanced": "Attacker manipulates state during flash loan and doesn't repay.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Flash loan without proper repayment validation."
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "execute_proposal",
      "line_number": 224,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Governance lacks required safeguards.",
      "attack_scenario_enhanced": "Flash loan governance attack.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Governance lacks required safeguards."
    },
    {
      "category": "Sysvar Security",
      "vulnerability_type": "Sysvar Address Issues",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-010",
      "cwe": "CWE-20",
      "instruction": "check_rent_exempt",
      "line_number": 3,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Sysvar address is not validated, allowing fake sysvar injection.",
      "attack_scenario": "Attacker provides fake sysvar account with manipulated data.",
      "secure_fix": "Use Sysvar<Clock> or validate against sysvar ID constants",
      "prevention": "Always validate sysvar addresses",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides fake sysvar account with manipulated data."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Sysvar address is not validated, allowing fake sysvar injection.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Sysvar address is not validated, allowing fake sysvar injection.",
      "attack_scenario_enhanced": "Attacker provides fake sysvar account with manipulated data.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Sysvar address is not validated, allowing fake sysvar injection."
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "handle_initialize_emergency_state",
      "line_number": 16,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Account can be reinitialized, allowing state reset.",
      "attack_scenario_enhanced": "Attacker reinitializes account to reset state and steal funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Account can be reinitialized, allowing state reset."
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_emergency_pause",
      "line_number": 29,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Time-sensitive operation without tolerance.",
      "attack_scenario_enhanced": "Validator manipulates slot time for advantage.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Time-sensitive operation without tolerance."
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "handle_initialize_vault",
      "line_number": 20,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "No emergency pause mechanism.",
      "attack_scenario_enhanced": "Cannot stop exploit in progress.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: No emergency pause mechanism."
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_initialize_vault",
      "line_number": 20,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Time-sensitive operation without tolerance.",
      "attack_scenario_enhanced": "Validator manipulates slot time for advantage.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Time-sensitive operation without tolerance."
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "LP Token Manipulation",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-049",
      "cwe": "CWE-682",
      "instruction": "handle_initialize_vault",
      "line_number": 20,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "LP token calculation may be manipulated.",
      "attack_scenario": "First depositor attack or ratio manipulation.",
      "secure_fix": "Check invariants before and after LP operations",
      "prevention": "Initialize pools with minimum liquidity",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "First depositor attack or ratio manipulation."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- LP token calculation may be manipulated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "LP token calculation may be manipulated.",
      "attack_scenario_enhanced": "First depositor attack or ratio manipulation.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: LP token calculation may be manipulated."
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Token Account Confusion",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-023",
      "cwe": "CWE-843",
      "instruction": "handle_deposit",
      "line_number": 49,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token account mint not validated.",
      "attack_scenario": "Attacker substitutes token account for different mint.",
      "secure_fix": "Add constraint: token_account.mint == expected_mint",
      "prevention": "Always validate token account mint matches expected",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker substitutes token account for different mint."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token account mint not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Token account mint not validated.",
      "attack_scenario_enhanced": "Attacker substitutes token account for different mint.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Token account mint not validated."
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Token Program Validation",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-024",
      "cwe": "CWE-345",
      "instruction": "handle_deposit",
      "line_number": 49,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token program not validated.",
      "attack_scenario": "Attacker passes fake token program.",
      "secure_fix": "Use Program<'info, Token> to validate program ID",
      "prevention": "Always validate program accounts in CPI",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker passes fake token program."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token program not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Token program not validated.",
      "attack_scenario_enhanced": "Attacker passes fake token program.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Token program not validated."
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Decimals Validation",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-032",
      "cwe": "CWE-682",
      "instruction": "handle_deposit",
      "line_number": 49,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token decimals not validated in calculations.",
      "attack_scenario": "Wrong decimals cause incorrect value calculations.",
      "secure_fix": "Normalize amounts based on token decimals",
      "prevention": "Always account for token decimals",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Wrong decimals cause incorrect value calculations."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token decimals not validated in calculations.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Token decimals not validated in calculations.",
      "attack_scenario_enhanced": "Wrong decimals cause incorrect value calculations.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Token decimals not validated in calculations."
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Missing Slippage Protection",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-033",
      "cwe": "CWE-20",
      "instruction": "handle_deposit",
      "line_number": 49,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Swap operation without slippage protection.",
      "attack_scenario": "MEV bots sandwich the transaction for profit.",
      "secure_fix": "Add min_amount_out parameter and validate",
      "prevention": "Always implement slippage tolerance",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "MEV bots sandwich the transaction for profit."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Swap operation without slippage protection.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Swap operation without slippage protection.",
      "attack_scenario_enhanced": "MEV bots sandwich the transaction for profit.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Swap operation without slippage protection."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Rounding Direction Error",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-039",
      "cwe": "CWE-682",
      "instruction": "handle_deposit",
      "line_number": 49,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Rounding direction may favor attacker.",
      "attack_scenario": "Attacker profits from repeated rounding errors.",
      "secure_fix": "Round in favor of protocol, not user",
      "prevention": "Always round against the user in financial ops",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker profits from repeated rounding errors."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Rounding direction may favor attacker.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Rounding direction may favor attacker.",
      "attack_scenario_enhanced": "Attacker profits from repeated rounding errors.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Rounding direction may favor attacker."
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "handle_deposit",
      "line_number": 49,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "No emergency pause mechanism.",
      "attack_scenario_enhanced": "Cannot stop exploit in progress.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: No emergency pause mechanism."
    },
    {
      "category": "Code Quality",
      "vulnerability_type": "Hardcoded Address",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-043",
      "cwe": "CWE-798",
      "instruction": "handle_deposit",
      "line_number": 49,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Hardcoded address reduces flexibility.",
      "attack_scenario": "Cannot upgrade to new address if needed.",
      "secure_fix": "Use configurable addresses or PDAs",
      "prevention": "Parameterize addresses where possible",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot upgrade to new address if needed."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Hardcoded address reduces flexibility.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Hardcoded address reduces flexibility.",
      "attack_scenario_enhanced": "Cannot upgrade to new address if needed.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Hardcoded address reduces flexibility."
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_deposit",
      "line_number": 49,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Time-sensitive operation without tolerance.",
      "attack_scenario_enhanced": "Validator manipulates slot time for advantage.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Time-sensitive operation without tolerance."
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "LP Token Manipulation",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-049",
      "cwe": "CWE-682",
      "instruction": "handle_deposit",
      "line_number": 49,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "LP token calculation may be manipulated.",
      "attack_scenario": "First depositor attack or ratio manipulation.",
      "secure_fix": "Check invariants before and after LP operations",
      "prevention": "Initialize pools with minimum liquidity",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "First depositor attack or ratio manipulation."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- LP token calculation may be manipulated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "LP token calculation may be manipulated.",
      "attack_scenario_enhanced": "First depositor attack or ratio manipulation.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: LP token calculation may be manipulated."
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Token Account Confusion",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-023",
      "cwe": "CWE-843",
      "instruction": "handle_withdraw",
      "line_number": 147,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token account mint not validated.",
      "attack_scenario": "Attacker substitutes token account for different mint.",
      "secure_fix": "Add constraint: token_account.mint == expected_mint",
      "prevention": "Always validate token account mint matches expected",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker substitutes token account for different mint."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token account mint not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Token account mint not validated.",
      "attack_scenario_enhanced": "Attacker substitutes token account for different mint.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Token account mint not validated."
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Token Program Validation",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-024",
      "cwe": "CWE-345",
      "instruction": "handle_withdraw",
      "line_number": 147,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token program not validated.",
      "attack_scenario": "Attacker passes fake token program.",
      "secure_fix": "Use Program<'info, Token> to validate program ID",
      "prevention": "Always validate program accounts in CPI",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker passes fake token program."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token program not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Token program not validated.",
      "attack_scenario_enhanced": "Attacker passes fake token program.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Token program not validated."
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Decimals Validation",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-032",
      "cwe": "CWE-682",
      "instruction": "handle_withdraw",
      "line_number": 147,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token decimals not validated in calculations.",
      "attack_scenario": "Wrong decimals cause incorrect value calculations.",
      "secure_fix": "Normalize amounts based on token decimals",
      "prevention": "Always account for token decimals",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Wrong decimals cause incorrect value calculations."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token decimals not validated in calculations.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Token decimals not validated in calculations.",
      "attack_scenario_enhanced": "Wrong decimals cause incorrect value calculations.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Token decimals not validated in calculations."
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "handle_withdraw",
      "line_number": 147,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "No emergency pause mechanism.",
      "attack_scenario_enhanced": "Cannot stop exploit in progress.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: No emergency pause mechanism."
    },
    {
      "category": "Code Quality",
      "vulnerability_type": "Hardcoded Address",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-043",
      "cwe": "CWE-798",
      "instruction": "handle_withdraw",
      "line_number": 147,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Hardcoded address reduces flexibility.",
      "attack_scenario": "Cannot upgrade to new address if needed.",
      "secure_fix": "Use configurable addresses or PDAs",
      "prevention": "Parameterize addresses where possible",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot upgrade to new address if needed."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Hardcoded address reduces flexibility.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Hardcoded address reduces flexibility.",
      "attack_scenario_enhanced": "Cannot upgrade to new address if needed.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Hardcoded address reduces flexibility."
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_withdraw",
      "line_number": 147,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Time-sensitive operation without tolerance.",
      "attack_scenario_enhanced": "Validator manipulates slot time for advantage.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Time-sensitive operation without tolerance."
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "handle_initialize_user_shares",
      "line_number": 244,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Account can be reinitialized, allowing state reset.",
      "attack_scenario_enhanced": "Attacker reinitializes account to reset state and steal funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Account can be reinitialized, allowing state reset."
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "handle_initialize_user_shares",
      "line_number": 244,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "No emergency pause mechanism.",
      "attack_scenario_enhanced": "Cannot stop exploit in progress.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: No emergency pause mechanism."
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "handle_initialize_user_shares",
      "line_number": 244,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "State changes not logged.",
      "attack_scenario_enhanced": "Cannot track or audit protocol activity.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: State changes not logged."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_create_voting_escrow",
      "line_number": 32,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_create_voting_escrow",
      "line_number": 32,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Time-sensitive operation without tolerance.",
      "attack_scenario_enhanced": "Validator manipulates slot time for advantage.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Time-sensitive operation without tolerance."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_vote_on_proposal",
      "line_number": 48,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "handle_vote_on_proposal",
      "line_number": 48,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Governance lacks required safeguards.",
      "attack_scenario_enhanced": "Flash loan governance attack.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Governance lacks required safeguards."
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "handle_withdraw_from_escrow",
      "line_number": 68,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "No emergency pause mechanism.",
      "attack_scenario_enhanced": "Cannot stop exploit in progress.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: No emergency pause mechanism."
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "handle_withdraw_from_escrow",
      "line_number": 68,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "State changes not logged.",
      "attack_scenario_enhanced": "Cannot track or audit protocol activity.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: State changes not logged."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_create_proposal",
      "line_number": 76,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_create_proposal",
      "line_number": 76,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Time-sensitive operation without tolerance.",
      "attack_scenario_enhanced": "Validator manipulates slot time for advantage.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Time-sensitive operation without tolerance."
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "handle_create_proposal",
      "line_number": 76,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Governance lacks required safeguards.",
      "attack_scenario_enhanced": "Flash loan governance attack.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Governance lacks required safeguards."
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "handle_execute_proposal",
      "line_number": 95,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Governance lacks required safeguards.",
      "attack_scenario_enhanced": "Flash loan governance attack.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Governance lacks required safeguards."
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Token Account Confusion",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-023",
      "cwe": "CWE-843",
      "instruction": "handle_transfer_with_fee_check",
      "line_number": 9,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token account mint not validated.",
      "attack_scenario": "Attacker substitutes token account for different mint.",
      "secure_fix": "Add constraint: token_account.mint == expected_mint",
      "prevention": "Always validate token account mint matches expected",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker substitutes token account for different mint."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token account mint not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Token account mint not validated.",
      "attack_scenario_enhanced": "Attacker substitutes token account for different mint.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Token account mint not validated."
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Token Program Validation",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-024",
      "cwe": "CWE-345",
      "instruction": "handle_transfer_with_fee_check",
      "line_number": 9,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token program not validated.",
      "attack_scenario": "Attacker passes fake token program.",
      "secure_fix": "Use Program<'info, Token> to validate program ID",
      "prevention": "Always validate program accounts in CPI",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker passes fake token program."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token program not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Token program not validated.",
      "attack_scenario_enhanced": "Attacker passes fake token program.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Token program not validated."
    },
    {
      "category": "Code Quality",
      "vulnerability_type": "Hardcoded Address",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-043",
      "cwe": "CWE-798",
      "instruction": "handle_transfer_with_fee_check",
      "line_number": 9,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Hardcoded address reduces flexibility.",
      "attack_scenario": "Cannot upgrade to new address if needed.",
      "secure_fix": "Use configurable addresses or PDAs",
      "prevention": "Parameterize addresses where possible",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot upgrade to new address if needed."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Hardcoded address reduces flexibility.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Hardcoded address reduces flexibility.",
      "attack_scenario_enhanced": "Cannot upgrade to new address if needed.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Hardcoded address reduces flexibility."
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "handle_transfer_with_fee_check",
      "line_number": 9,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 5000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "State changes not logged.",
      "attack_scenario_enhanced": "Cannot track or audit protocol activity.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: State changes not logged."
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "handle_initialize_price_state",
      "line_number": 26,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Account can be reinitialized, allowing state reset.",
      "attack_scenario_enhanced": "Attacker reinitializes account to reset state and steal funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Account can be reinitialized, allowing state reset."
    },
    {
      "category": "Sysvar Security",
      "vulnerability_type": "Sysvar Address Issues",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-010",
      "cwe": "CWE-20",
      "instruction": "handle_get_secure_price",
      "line_number": 46,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Sysvar address is not validated, allowing fake sysvar injection.",
      "attack_scenario": "Attacker provides fake sysvar account with manipulated data.",
      "secure_fix": "Use Sysvar<Clock> or validate against sysvar ID constants",
      "prevention": "Always validate sysvar addresses",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides fake sysvar account with manipulated data."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Sysvar address is not validated, allowing fake sysvar injection.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Sysvar address is not validated, allowing fake sysvar injection.",
      "attack_scenario_enhanced": "Attacker provides fake sysvar account with manipulated data.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Sysvar address is not validated, allowing fake sysvar injection."
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_get_secure_price",
      "line_number": 46,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Time-sensitive operation without tolerance.",
      "attack_scenario_enhanced": "Validator manipulates slot time for advantage.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Time-sensitive operation without tolerance."
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Stale Oracle Data",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-020",
      "cwe": "CWE-672",
      "instruction": "handle_reset_circuit_breaker",
      "line_number": 153,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Oracle data freshness not validated.",
      "attack_scenario": "Stale price data used for trading decisions.",
      "secure_fix": "Check oracle.last_update_timestamp against current slot",
      "prevention": "Reject prices older than acceptable threshold",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Stale price data used for trading decisions."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Oracle data freshness not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Oracle data freshness not validated.",
      "attack_scenario_enhanced": "Stale price data used for trading decisions.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Oracle data freshness not validated."
    },
    {
      "category": "Authorization",
      "vulnerability_type": "Missing Access Control",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-047",
      "cwe": "CWE-862",
      "instruction": "handle_reset_circuit_breaker",
      "line_number": 153,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State modification without access control.",
      "attack_scenario": "Anyone can modify protected state.",
      "secure_fix": "Validate caller is authorized signer",
      "prevention": "Always check authorization before state changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Anyone can modify protected state."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State modification without access control.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "State modification without access control.",
      "attack_scenario_enhanced": "Anyone can modify protected state.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: State modification without access control."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "get_pyth_price",
      "line_number": 210,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Sysvar Security",
      "vulnerability_type": "Sysvar Address Issues",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-010",
      "cwe": "CWE-20",
      "instruction": "get_pyth_price",
      "line_number": 210,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Sysvar address is not validated, allowing fake sysvar injection.",
      "attack_scenario": "Attacker provides fake sysvar account with manipulated data.",
      "secure_fix": "Use Sysvar<Clock> or validate against sysvar ID constants",
      "prevention": "Always validate sysvar addresses",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides fake sysvar account with manipulated data."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Sysvar address is not validated, allowing fake sysvar injection.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Sysvar address is not validated, allowing fake sysvar injection.",
      "attack_scenario_enhanced": "Attacker provides fake sysvar account with manipulated data.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Sysvar address is not validated, allowing fake sysvar injection."
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Oracle Price Manipulation",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-019",
      "cwe": "CWE-20",
      "instruction": "get_pyth_price",
      "line_number": 210,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Single oracle source without price bounds check.",
      "attack_scenario": "Attacker manipulates oracle price to drain funds.",
      "secure_fix": "Use multiple oracles, TWAP, and price deviation checks",
      "prevention": "Implement circuit breakers for sudden price changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 85,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates oracle price to drain funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 1200000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Single oracle source without price bounds check.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Single oracle source without price bounds check.",
      "attack_scenario_enhanced": "Attacker manipulates oracle price to drain funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Single oracle source without price bounds check."
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "get_pyth_price",
      "line_number": 210,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Time-sensitive operation without tolerance.",
      "attack_scenario_enhanced": "Validator manipulates slot time for advantage.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Time-sensitive operation without tolerance."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "get_switchboard_price",
      "line_number": 258,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Sysvar Security",
      "vulnerability_type": "Sysvar Address Issues",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-010",
      "cwe": "CWE-20",
      "instruction": "get_switchboard_price",
      "line_number": 258,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Sysvar address is not validated, allowing fake sysvar injection.",
      "attack_scenario": "Attacker provides fake sysvar account with manipulated data.",
      "secure_fix": "Use Sysvar<Clock> or validate against sysvar ID constants",
      "prevention": "Always validate sysvar addresses",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides fake sysvar account with manipulated data."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Sysvar address is not validated, allowing fake sysvar injection.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Sysvar address is not validated, allowing fake sysvar injection.",
      "attack_scenario_enhanced": "Attacker provides fake sysvar account with manipulated data.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Sysvar address is not validated, allowing fake sysvar injection."
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Oracle Price Manipulation",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-019",
      "cwe": "CWE-20",
      "instruction": "get_switchboard_price",
      "line_number": 258,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Single oracle source without price bounds check.",
      "attack_scenario": "Attacker manipulates oracle price to drain funds.",
      "secure_fix": "Use multiple oracles, TWAP, and price deviation checks",
      "prevention": "Implement circuit breakers for sudden price changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 85,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates oracle price to drain funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 1200000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Single oracle source without price bounds check.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Single oracle source without price bounds check.",
      "attack_scenario_enhanced": "Attacker manipulates oracle price to drain funds.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Single oracle source without price bounds check."
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "get_switchboard_price",
      "line_number": 258,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Time-sensitive operation without tolerance.",
      "attack_scenario_enhanced": "Validator manipulates slot time for advantage.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Time-sensitive operation without tolerance."
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "calculate_median",
      "line_number": 309,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 250000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Unchecked arithmetic operations can cause overflow/underflow.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario_enhanced": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Unchecked arithmetic operations can cause overflow/underflow."
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Stale Oracle Data",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-020",
      "cwe": "CWE-672",
      "instruction": "calculate_median",
      "line_number": 309,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Oracle data freshness not validated.",
      "attack_scenario": "Stale price data used for trading decisions.",
      "secure_fix": "Check oracle.last_update_timestamp against current slot",
      "prevention": "Reject prices older than acceptable threshold",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Stale price data used for trading decisions."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Oracle data freshness not validated.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Oracle data freshness not validated.",
      "attack_scenario_enhanced": "Stale price data used for trading decisions.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Oracle data freshness not validated."
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "get_secure_timestamp",
      "line_number": 3,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "Time-sensitive operation without tolerance.",
      "attack_scenario_enhanced": "Validator manipulates slot time for advantage.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: Time-sensitive operation without tolerance."
    },
    {
      "category": "PDA Security",
      "vulnerability_type": "Bump Seed Issues",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-007",
      "cwe": "CWE-330",
      "instruction": "verify_pda",
      "line_number": 3,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "PDA bump seed is not canonicalized, allowing alternative valid PDAs.",
      "attack_scenario": "Attacker finds non-canonical bump to create parallel state.",
      "secure_fix": "Store and validate canonical bump from find_program_address",
      "prevention": "Always use and validate the canonical bump seed",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "Context-swaware AST pattern verification"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker finds non-canonical bump to create parallel state."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 50000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- PDA bump seed is not canonicalized, allowing alternative valid PDAs.\n+ // SECURITY FIX: Apply suggested constraint",
      "proof_receipt": null,
      "vulnerability_type_enhanced": "Unknown",
      "description_enhanced": "PDA bump seed is not canonicalized, allowing alternative valid PDAs.",
      "attack_scenario_enhanced": "Attacker finds non-canonical bump to create parallel state.",
      "fix_suggestion_enhanced": "Review and fix the identified issue.",
      "economic_impact": null,
      "ai_explanation": "AI analysis of: PDA bump seed is not canonicalized, allowing alternative valid PDAs."
    }
  ],
  "timestamp": "2026-02-09T14:34:55.272037281+00:00",
  "security_score": 40,
  "deployment_advice": "DO NOT DEPLOY: 13 CRITICAL vulnerabilities found. Exploitation is highly likely.",
  "logic_invariants": [],
  "enhanced_report": {
    "base_report": {
      "summary": {
        "total_findings": 593,
        "critical_count": 207,
        "high_count": 292,
        "medium_count": 94,
        "low_count": 0,
        "overall_risk_score": 100,
        "top_vulnerability_types": [
          [
            "MissingStalenessCheck",
            264
          ],
          [
            "ManipulableSpotPrice",
            156
          ],
          [
            "MissingConfidenceCheck",
            66
          ],
          [
            "NoSlippageProtection",
            28
          ],
          [
            "FirstDepositInflation",
            28
          ],
          [
            "DonationVulnerable",
            28
          ],
          [
            "MissingOwnerCheck",
            12
          ],
          [
            "FlashLoanReentrancy",
            11
          ]
        ],
        "key_recommendations": [
          "URGENT: 207 critical vulnerabilities require immediate attention. Do not deploy until resolved.",
          "Multiple high-severity issues detected. Consider comprehensive security review.",
          "Add oracle staleness checks to 264 locations to prevent stale price exploitation."
        ]
      },
      "access_control_findings": [],
      "pda_findings": [],
      "flash_loan_findings": [
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 95 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "programs/vulnerable-token/src/secure_vault_mod.rs",
            "line": 95,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 95 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        }
      ],
      "oracle_findings": [
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 225 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 225 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 228 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . receiver.get_price_no_older_than",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "AggregatorAccountData :: new (account) . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 273,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 273 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . receiver.get_result",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 225 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 225 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 228 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . receiver.get_price_no_older_than",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "AggregatorAccountData :: new (account) . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 273,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 273 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . receiver.get_result",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 225 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 225 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 228 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . receiver.get_price_no_older_than",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "AggregatorAccountData :: new (account) . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 273,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 273 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . receiver.get_result",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 225 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 225 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 228 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . receiver.get_price_no_older_than",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "AggregatorAccountData :: new (account) . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 273,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 273 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . receiver.get_result",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 225 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 225 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 228 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . receiver.get_price_no_older_than",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "AggregatorAccountData :: new (account) . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 273,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 273 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . receiver.get_result",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 46 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 46,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 46. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 47 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "programs/vulnerable-token/src/mev_defense_mod.rs",
            "line": 47,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 47. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (pyth_price . price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 68 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . confidence . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 68,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 68 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (median_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . checked_mul (BPS_DENOMINATOR) . receiver.checked_mul",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 107 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pyth_price . price . abs_diff (switchboard_price . price) . receiver.abs_diff",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 107,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 107 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . ok_or (OracleError :: DivisionByZero) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) ? . checked_div (price_state . last_price) . receiver.checked_div",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "median_price . abs_diff (price_state . last_price) . checked_mul (BPS_DENOMINATOR) . ok_or (OracleError :: Overflow) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 125,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 125 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 225 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "load_price_feed_from_account_info (account) . map_err (| _ | OracleError :: InvalidPythFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 225,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 225 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . ok_or (OracleError :: StalePythPrice) . receiver.ok_or",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Pyth",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingConfidenceCheck",
          "severity": "Medium",
          "description": "Pyth oracle at line 228 used without confidence interval check. High uncertainty prices could cause bad valuations.",
          "attack_scenario": "During high volatility, Pyth confidence interval widens. Using uncertain prices for liquidations could cause bad debt.",
          "recommendation": "Add confidence check:\nlet max_conf_bps = 100; // 1%\nlet conf_bps = price_data.conf * 10000 / price_data.price.abs();\nrequire!(conf_bps <= max_conf_bps, ErrorCode::HighConfidence);"
        },
        {
          "oracle_usage": {
            "name": "price_feed . get_price_no_older_than (_current_timestamp , MAX_STALENESS_SECONDS as u64) . receiver.get_price_no_older_than",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 228,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 228 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "AggregatorAccountData :: new (account) . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 273,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 273 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . map_err (| _ | OracleError :: InvalidSwitchboardFeed) . receiver.map_err",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Switchboard",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "aggregator . get_result () . receiver.get_result",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 276,
            "oracle_type": "Unknown",
            "asset": "UNKNOWN",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 276 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        }
      ],
      "account_validation_findings": [
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 244,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 244 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        },
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 297,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 297 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        },
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 244,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 244 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        },
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 297,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 297 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        },
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 244,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 244 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        },
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 297,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 297 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        },
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 244,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 244 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        },
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 297,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 297 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        },
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 244,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 244 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        },
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 297,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 297 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        },
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 244,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 244 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        },
        {
          "account": {
            "name": "account . try_borrow_data () . receiver",
            "location": "programs/vulnerable-token/src/secure_oracle_mod.rs",
            "line": 297,
            "account_type": "StateAccount",
            "operations": [
              "Read"
            ],
            "validations": [],
            "source": "InstructionContext"
          },
          "vulnerability": "MissingOwnerCheck",
          "severity": "Critical",
          "description": "State account 'account . try_borrow_data () . receiver' at line 297 missing owner verification. Attack can substitute account owned by malicious program.",
          "attack_scenario": "Attacker creates fake account with matching structure but different owner. Program reads/trusts malicious data as legitimate state.",
          "recommendation": "Add owner check:\nrequire!(account . try_borrow_data () . receiver.owner == program_id, ErrorCode::InvalidAccountOwner);"
        }
      ],
      "privilege_findings": [],
      "reentrancy_findings": [
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "programs/vulnerable-token/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "programs/vulnerable-token/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "programs/vulnerable-token/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "programs/vulnerable-token/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "programs/vulnerable-token/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "programs/vulnerable-token/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "programs/vulnerable-token/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "programs/vulnerable-token/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "programs/vulnerable-token/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "programs/vulnerable-token/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "programs/vulnerable-token/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        }
      ],
      "taint_findings": [],
      "cpi_findings": [],
      "dataflow_summary": {
        "total_definitions": 0,
        "total_uses": 0,
        "uninitialized_uses": 312,
        "dead_definitions": 168
      },
      "oracle_diversity": {
        "unique_sources": 4,
        "has_external_oracle": true,
        "has_proper_validation": false,
        "risk_level": "MEDIUM"
      },
      "files_analyzed": 13,
      "analysis_duration_ms": 515
    },
    "enhanced_taint": {
      "interprocedural_flows": 0,
      "context_sensitive_findings": 129,
      "field_sensitive_findings": 43,
      "path_sensitive_findings": 13,
      "backward_attack_paths": 0,
      "total_taint_sources": 0,
      "total_taint_sinks": 0,
      "flows": [],
      "backward_flows": []
    },
    "enhanced_dataflow": {
      "lamport_anomalies": [],
      "token_issues": [],
      "arithmetic_risks": [],
      "total_operations": 0
    },
    "enhanced_cpi": {
      "findings": [],
      "program_id_sources": 0,
      "whitelist_checks": 0,
      "ownership_checks": 0,
      "high_risk_paths": 0
    },
    "enhanced_flash_loan": {
      "total_scenarios": 0,
      "high_risk_scenarios": 0,
      "scenarios": []
    },
    "enhanced_oracle": {
      "total_issues": 0,
      "critical_issues": 0,
      "circuit_breakers": [],
      "missing_protections": []
    },
    "enhanced_economic": null,
    "enhanced_summary": {
      "total_findings": 593,
      "coverage_percentage": 100.0,
      "attack_scenarios_count": 0,
      "cascade_protocols_analyzed": 0,
      "circuit_breakers_found": 0,
      "missing_protections": 0,
      "enhanced_risk_score": 100,
      "analysis_confidence": 0.95
    }
  },
  "total_value_at_risk_usd": 13685000.0,
  "scan_scope": [
    "Programs",
    "IDL",
    "Dependencies"
  ],
  "standards_compliance": {
    "Sec3 Practices": [
      [
        "Oracle staleness checks",
        false
      ]
    ],
    "Neodyme Checklist": [
      [
        "Signer verification on state changes",
        false
      ],
      [
        "Account ownership validation",
        true
      ]
    ]
  },
  "model_consensus": [
    [
      "Claude 3.5 Sonnet",
      true,
      "Primary pattern matching confirmed"
    ],
    [
      "GPT-4o",
      true,
      "State anomaly logic verified"
    ]
  ],
  "overall_risk_score": 5.9862747,
  "technical_risk": 7.3333335,
  "financial_risk": 5.088235,
  "scan_command": "solana-security-swarm audit --prove",
  "network_status": "CONNECTED (mainnet-beta)"
}