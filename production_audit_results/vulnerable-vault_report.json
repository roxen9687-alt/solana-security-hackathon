{
  "program_id": "vulnerable-vault",
  "total_exploits": 92,
  "critical_count": 12,
  "high_count": 48,
  "medium_count": 23,
  "exploits": [
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_initialize_pool",
      "line_number": 18,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -18,1 +18,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "handle_initialize_pool",
      "line_number": 18,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_swap_with_protection",
      "line_number": 35,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -35,1 +35,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Token Account Confusion",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-023",
      "cwe": "CWE-843",
      "instruction": "handle_swap_with_protection",
      "line_number": 35,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token account mint not validated.",
      "attack_scenario": "Attacker substitutes token account for different mint.",
      "secure_fix": "Add constraint: token_account.mint == expected_mint",
      "prevention": "Always validate token account mint matches expected",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker substitutes token account for different mint."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token account mint not validated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Token Program Validation",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-024",
      "cwe": "CWE-345",
      "instruction": "handle_swap_with_protection",
      "line_number": 35,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token program not validated.",
      "attack_scenario": "Attacker passes fake token program.",
      "secure_fix": "Use Program<'info, Token> to validate program ID",
      "prevention": "Always validate program accounts in CPI",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker passes fake token program."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token program not validated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Decimals Validation",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-032",
      "cwe": "CWE-682",
      "instruction": "handle_swap_with_protection",
      "line_number": 35,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token decimals not validated in calculations.",
      "attack_scenario": "Wrong decimals cause incorrect value calculations.",
      "secure_fix": "Normalize amounts based on token decimals",
      "prevention": "Always account for token decimals",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Wrong decimals cause incorrect value calculations."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token decimals not validated in calculations.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Missing Slippage Protection",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-033",
      "cwe": "CWE-20",
      "instruction": "handle_swap_with_protection",
      "line_number": 35,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Swap operation without slippage protection.",
      "attack_scenario": "MEV bots sandwich the transaction for profit.",
      "secure_fix": "Add min_amount_out parameter and validate",
      "prevention": "Always implement slippage tolerance",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "MEV bots sandwich the transaction for profit."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Swap operation without slippage protection.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "handle_swap_with_protection",
      "line_number": 35,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "handle_swap_with_protection",
      "line_number": 35,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_swap_with_protection",
      "line_number": 35,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "verify_transfer_amount",
      "line_number": 39,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -39,1 +39,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Token Program Validation",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-024",
      "cwe": "CWE-345",
      "instruction": "verify_transfer_amount",
      "line_number": 39,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token program not validated.",
      "attack_scenario": "Attacker passes fake token program.",
      "secure_fix": "Use Program<'info, Token> to validate program ID",
      "prevention": "Always validate program accounts in CPI",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker passes fake token program."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token program not validated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "verify_transfer_amount",
      "line_number": 39,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "swap_with_protection",
      "line_number": 58,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -58,1 +58,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Missing Slippage Protection",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-033",
      "cwe": "CWE-20",
      "instruction": "swap_with_protection",
      "line_number": 58,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Swap operation without slippage protection.",
      "attack_scenario": "MEV bots sandwich the transaction for profit.",
      "secure_fix": "Add min_amount_out parameter and validate",
      "prevention": "Always implement slippage tolerance",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "MEV bots sandwich the transaction for profit."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Swap operation without slippage protection.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "swap_with_protection",
      "line_number": 58,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "get_secure_price",
      "line_number": 74,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -74,1 +74,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Oracle Price Manipulation",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-019",
      "cwe": "CWE-20",
      "instruction": "get_secure_price",
      "line_number": 74,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Single oracle source without price bounds check.",
      "attack_scenario": "Attacker manipulates oracle price to drain funds.",
      "secure_fix": "Use multiple oracles, TWAP, and price deviation checks",
      "prevention": "Implement circuit breakers for sudden price changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 85,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates oracle price to drain funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 900000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Single oracle source without price bounds check.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Stale Oracle Data",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-020",
      "cwe": "CWE-672",
      "instruction": "get_secure_price",
      "line_number": 74,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Oracle data freshness not validated.",
      "attack_scenario": "Stale price data used for trading decisions.",
      "secure_fix": "Check oracle.last_update_timestamp against current slot",
      "prevention": "Reject prices older than acceptable threshold",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Stale price data used for trading decisions."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Oracle data freshness not validated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "deposit",
      "line_number": 83,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -83,1 +83,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "deposit",
      "line_number": 83,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "deposit",
      "line_number": 83,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "create_voting_escrow",
      "line_number": 96,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -96,1 +96,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "create_voting_escrow",
      "line_number": 96,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "initialize_emergency_state",
      "line_number": 108,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "initialize_vault",
      "line_number": 132,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "withdraw",
      "line_number": 141,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -141,1 +141,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "withdraw",
      "line_number": 141,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "withdraw",
      "line_number": 141,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "initialize_user_shares",
      "line_number": 153,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "initialize_price_state",
      "line_number": 161,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Oracle Price Manipulation",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-019",
      "cwe": "CWE-20",
      "instruction": "initialize_price_state",
      "line_number": 161,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Single oracle source without price bounds check.",
      "attack_scenario": "Attacker manipulates oracle price to drain funds.",
      "secure_fix": "Use multiple oracles, TWAP, and price deviation checks",
      "prevention": "Implement circuit breakers for sudden price changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 85,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates oracle price to drain funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 900000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Single oracle source without price bounds check.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Stale Oracle Data",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-020",
      "cwe": "CWE-672",
      "instruction": "initialize_price_state",
      "line_number": 161,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Oracle data freshness not validated.",
      "attack_scenario": "Stale price data used for trading decisions.",
      "secure_fix": "Check oracle.last_update_timestamp against current slot",
      "prevention": "Reject prices older than acceptable threshold",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Stale price data used for trading decisions."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Oracle data freshness not validated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Oracle Price Manipulation",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-019",
      "cwe": "CWE-20",
      "instruction": "reset_circuit_breaker",
      "line_number": 170,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Single oracle source without price bounds check.",
      "attack_scenario": "Attacker manipulates oracle price to drain funds.",
      "secure_fix": "Use multiple oracles, TWAP, and price deviation checks",
      "prevention": "Implement circuit breakers for sudden price changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 85,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates oracle price to drain funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 900000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Single oracle source without price bounds check.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Stale Oracle Data",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-020",
      "cwe": "CWE-672",
      "instruction": "reset_circuit_breaker",
      "line_number": 170,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Oracle data freshness not validated.",
      "attack_scenario": "Stale price data used for trading decisions.",
      "secure_fix": "Check oracle.last_update_timestamp against current slot",
      "prevention": "Reject prices older than acceptable threshold",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Stale price data used for trading decisions."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Oracle data freshness not validated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Authorization",
      "vulnerability_type": "Missing Access Control",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-047",
      "cwe": "CWE-862",
      "instruction": "reset_circuit_breaker",
      "line_number": 170,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State modification without access control.",
      "attack_scenario": "Anyone can modify protected state.",
      "secure_fix": "Validate caller is authorized signer",
      "prevention": "Always check authorization before state changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Anyone can modify protected state."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State modification without access control.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "initialize_pool",
      "line_number": 177,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -177,1 +177,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "initialize_pool",
      "line_number": 177,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "vote_on_proposal",
      "line_number": 188,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -188,1 +188,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "vote_on_proposal",
      "line_number": 188,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "vote_on_proposal",
      "line_number": 188,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "extend_lock",
      "line_number": 198,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "withdraw_from_escrow",
      "line_number": 206,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "withdraw_from_escrow",
      "line_number": 206,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "withdraw_from_escrow",
      "line_number": 206,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "create_proposal",
      "line_number": 213,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -213,1 +213,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "create_proposal",
      "line_number": 213,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "create_proposal",
      "line_number": 213,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "execute_proposal",
      "line_number": 224,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -224,1 +224,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "Flash Loan Vulnerability",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-018",
      "cwe": "CWE-362",
      "instruction": "execute_proposal",
      "line_number": 224,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Flash loan without proper repayment validation.",
      "attack_scenario": "Attacker manipulates state during flash loan and doesn't repay.",
      "secure_fix": "Verify repayment + fee at end of flash loan instruction",
      "prevention": "Track pre/post balances and enforce invariants",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates state during flash loan and doesn't repay."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Flash loan without proper repayment validation.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "execute_proposal",
      "line_number": 224,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "handle_initialize_emergency_state",
      "line_number": 16,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_emergency_pause",
      "line_number": 29,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "handle_initialize_vault",
      "line_number": 28,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "DeFi Security",
      "vulnerability_type": "LP Token Manipulation",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-049",
      "cwe": "CWE-682",
      "instruction": "handle_initialize_vault",
      "line_number": 28,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "LP token calculation may be manipulated.",
      "attack_scenario": "First depositor attack or ratio manipulation.",
      "secure_fix": "Check invariants before and after LP operations",
      "prevention": "Initialize pools with minimum liquidity",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "First depositor attack or ratio manipulation."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- LP token calculation may be manipulated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "handle_initialize_user_shares",
      "line_number": 42,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Token Account Confusion",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-023",
      "cwe": "CWE-843",
      "instruction": "handle_deposit",
      "line_number": 53,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token account mint not validated.",
      "attack_scenario": "Attacker substitutes token account for different mint.",
      "secure_fix": "Add constraint: token_account.mint == expected_mint",
      "prevention": "Always validate token account mint matches expected",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker substitutes token account for different mint."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token account mint not validated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Token Program Validation",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-024",
      "cwe": "CWE-345",
      "instruction": "handle_deposit",
      "line_number": 53,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token program not validated.",
      "attack_scenario": "Attacker passes fake token program.",
      "secure_fix": "Use Program<'info, Token> to validate program ID",
      "prevention": "Always validate program accounts in CPI",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker passes fake token program."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token program not validated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Decimals Validation",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-032",
      "cwe": "CWE-682",
      "instruction": "handle_deposit",
      "line_number": 53,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token decimals not validated in calculations.",
      "attack_scenario": "Wrong decimals cause incorrect value calculations.",
      "secure_fix": "Normalize amounts based on token decimals",
      "prevention": "Always account for token decimals",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Wrong decimals cause incorrect value calculations."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token decimals not validated in calculations.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Rounding Direction Error",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-039",
      "cwe": "CWE-682",
      "instruction": "handle_deposit",
      "line_number": 53,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Rounding direction may favor attacker.",
      "attack_scenario": "Attacker profits from repeated rounding errors.",
      "secure_fix": "Round in favor of protocol, not user",
      "prevention": "Always round against the user in financial ops",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker profits from repeated rounding errors."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Rounding direction may favor attacker.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "handle_deposit",
      "line_number": 53,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "handle_deposit",
      "line_number": 53,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Rounding Direction Error",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-039",
      "cwe": "CWE-682",
      "instruction": "handle_withdraw",
      "line_number": 83,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Rounding direction may favor attacker.",
      "attack_scenario": "Attacker profits from repeated rounding errors.",
      "secure_fix": "Round in favor of protocol, not user",
      "prevention": "Always round against the user in financial ops",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker profits from repeated rounding errors."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Rounding direction may favor attacker.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "handle_withdraw",
      "line_number": 83,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "handle_withdraw",
      "line_number": 83,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_create_voting_escrow",
      "line_number": 30,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -30,1 +30,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_create_voting_escrow",
      "line_number": 30,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_vote_on_proposal",
      "line_number": 45,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -45,1 +45,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "handle_vote_on_proposal",
      "line_number": 45,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Sysvar Security",
      "vulnerability_type": "Sysvar Address Issues",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-010",
      "cwe": "CWE-20",
      "instruction": "handle_withdraw_from_escrow",
      "line_number": 77,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Sysvar address is not validated, allowing fake sysvar injection.",
      "attack_scenario": "Attacker provides fake sysvar account with manipulated data.",
      "secure_fix": "Use Sysvar<Clock> or validate against sysvar ID constants",
      "prevention": "Always validate sysvar addresses",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides fake sysvar account with manipulated data."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Sysvar address is not validated, allowing fake sysvar injection.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Protocol Safety",
      "vulnerability_type": "Missing Pause Mechanism",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-042",
      "cwe": "CWE-754",
      "instruction": "handle_withdraw_from_escrow",
      "line_number": 77,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "No emergency pause mechanism.",
      "attack_scenario": "Cannot stop exploit in progress.",
      "secure_fix": "Implement pausable pattern with admin control",
      "prevention": "Always have emergency controls",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot stop exploit in progress."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- No emergency pause mechanism.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "handle_withdraw_from_escrow",
      "line_number": 77,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_withdraw_from_escrow",
      "line_number": 77,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_create_proposal",
      "line_number": 87,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -87,1 +87,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_create_proposal",
      "line_number": 87,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "handle_create_proposal",
      "line_number": 87,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_execute_proposal",
      "line_number": 105,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Governance",
      "vulnerability_type": "Governance Attack",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-052",
      "cwe": "CWE-284",
      "instruction": "handle_execute_proposal",
      "line_number": 105,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Governance lacks required safeguards.",
      "attack_scenario": "Flash loan governance attack.",
      "secure_fix": "Implement timelock and voting snapshot",
      "prevention": "Use battle-tested governance patterns",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Flash loan governance attack."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Governance lacks required safeguards.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_transfer_with_fee_check",
      "line_number": 4,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -4,1 +4,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Token Account Confusion",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-023",
      "cwe": "CWE-843",
      "instruction": "handle_transfer_with_fee_check",
      "line_number": 4,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token account mint not validated.",
      "attack_scenario": "Attacker substitutes token account for different mint.",
      "secure_fix": "Add constraint: token_account.mint == expected_mint",
      "prevention": "Always validate token account mint matches expected",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker substitutes token account for different mint."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token account mint not validated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Token Security",
      "vulnerability_type": "Missing Token Program Validation",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-024",
      "cwe": "CWE-345",
      "instruction": "handle_transfer_with_fee_check",
      "line_number": 4,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Token program not validated.",
      "attack_scenario": "Attacker passes fake token program.",
      "secure_fix": "Use Program<'info, Token> to validate program ID",
      "prevention": "Always validate program accounts in CPI",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker passes fake token program."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Token program not validated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Observability",
      "vulnerability_type": "Missing Event Emission",
      "severity": 2,
      "severity_label": "LOW",
      "id": "SOL-044",
      "cwe": null,
      "instruction": "handle_transfer_with_fee_check",
      "line_number": 4,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State changes not logged.",
      "attack_scenario": "Cannot track or audit protocol activity.",
      "secure_fix": "Emit events for all significant state changes",
      "prevention": "Always emit events for important operations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 75,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Cannot track or audit protocol activity."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 12000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State changes not logged.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Initialization",
      "vulnerability_type": "Reinitialization Vulnerability",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-011",
      "cwe": "CWE-665",
      "instruction": "handle_initialize_price_state",
      "line_number": 17,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Account can be reinitialized, allowing state reset.",
      "attack_scenario": "Attacker reinitializes account to reset state and steal funds.",
      "secure_fix": "Check is_initialized flag or use Anchor's init constraint",
      "prevention": "Always prevent reinitialization",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker reinitializes account to reset state and steal funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Account can be reinitialized, allowing state reset.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_initialize_price_state",
      "line_number": 17,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Arithmetic",
      "vulnerability_type": "Integer Overflow/Underflow",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-002",
      "cwe": "CWE-190",
      "instruction": "handle_get_secure_price",
      "line_number": 32,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Unchecked arithmetic operations can cause overflow/underflow.",
      "attack_scenario": "Attacker provides values that cause arithmetic to wrap, manipulating balances.",
      "secure_fix": "Use checked_add, checked_sub, checked_mul or require overflow-checks=true",
      "prevention": "Always use checked arithmetic for financial calculations",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 92,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "CRITICAL",
      "priority_index": 1,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides values that cause arithmetic to wrap, manipulating balances."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 540000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -32,1 +32,1 @@\n-    user_account.balance += amount;\n+    user_account.balance = user_account.balance.checked_add(amount).ok_or(ErrorCode::Overflow)?;",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Sysvar Security",
      "vulnerability_type": "Sysvar Address Issues",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-010",
      "cwe": "CWE-20",
      "instruction": "handle_get_secure_price",
      "line_number": 32,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Sysvar address is not validated, allowing fake sysvar injection.",
      "attack_scenario": "Attacker provides fake sysvar account with manipulated data.",
      "secure_fix": "Use Sysvar<Clock> or validate against sysvar ID constants",
      "prevention": "Always validate sysvar addresses",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker provides fake sysvar account with manipulated data."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Sysvar address is not validated, allowing fake sysvar injection.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Oracle Price Manipulation",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-019",
      "cwe": "CWE-20",
      "instruction": "handle_get_secure_price",
      "line_number": 32,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Single oracle source without price bounds check.",
      "attack_scenario": "Attacker manipulates oracle price to drain funds.",
      "secure_fix": "Use multiple oracles, TWAP, and price deviation checks",
      "prevention": "Implement circuit breakers for sudden price changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 85,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker manipulates oracle price to drain funds."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 900000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Single oracle source without price bounds check.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "handle_get_secure_price",
      "line_number": 32,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Oracle Security",
      "vulnerability_type": "Stale Oracle Data",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-020",
      "cwe": "CWE-672",
      "instruction": "handle_reset_circuit_breaker",
      "line_number": 45,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Oracle data freshness not validated.",
      "attack_scenario": "Stale price data used for trading decisions.",
      "secure_fix": "Check oracle.last_update_timestamp against current slot",
      "prevention": "Reject prices older than acceptable threshold",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Stale price data used for trading decisions."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Oracle data freshness not validated.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Authorization",
      "vulnerability_type": "Missing Access Control",
      "severity": 5,
      "severity_label": "CRITICAL",
      "id": "SOL-047",
      "cwe": "CWE-862",
      "instruction": "handle_reset_circuit_breaker",
      "line_number": 45,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "State modification without access control.",
      "attack_scenario": "Anyone can modify protected state.",
      "secure_fix": "Validate caller is authorized signer",
      "prevention": "Always check authorization before state changes",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Anyone can modify protected state."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- State modification without access control.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "Time Safety",
      "vulnerability_type": "Time Manipulation Risk",
      "severity": 3,
      "severity_label": "MEDIUM",
      "id": "SOL-046",
      "cwe": "CWE-367",
      "instruction": "get_timestamp",
      "line_number": 3,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "Time-sensitive operation without tolerance.",
      "attack_scenario": "Validator manipulates slot time for advantage.",
      "secure_fix": "Add time buffer for critical operations",
      "prevention": "Don't rely on exact timestamps",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Validator manipulates slot time for advantage."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- Time-sensitive operation without tolerance.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    },
    {
      "category": "PDA Security",
      "vulnerability_type": "Bump Seed Issues",
      "severity": 4,
      "severity_label": "HIGH",
      "id": "SOL-007",
      "cwe": "CWE-330",
      "instruction": "find_pda_with_bump",
      "line_number": 3,
      "proof_tx": "AWAITING_VERIFICATION",
      "error_code": 6000,
      "description": "PDA bump seed is not canonicalized, allowing alternative valid PDAs.",
      "attack_scenario": "Attacker finds non-canonical bump to create parallel state.",
      "secure_fix": "Store and validate canonical bump from find_program_address",
      "prevention": "Always use and validate the canonical bump seed",
      "attack_simulation": null,
      "state": "Discovered",
      "fix_metadata": null,
      "confidence_score": 82,
      "confidence_reasoning": [
        "AST multi-path verification confirmed pattern"
      ],
      "risk_priority": "HIGH",
      "priority_index": 3,
      "exploit_gas_estimate": 10000,
      "exploit_steps": [
        "Attacker finds non-canonical bump to create parallel state."
      ],
      "exploit_complexity": "LOW",
      "value_at_risk_usd": 120000.0,
      "cve_reference": null,
      "historical_hack_context": null,
      "mitigation_diff": "- PDA bump seed is not canonicalized, allowing alternative valid PDAs.\n+ // FIX: Apply internal validation to block this attack vector",
      "proof_receipt": null,
      "vulnerability_type_enhanced": null,
      "description_enhanced": null,
      "attack_scenario_enhanced": null,
      "fix_suggestion_enhanced": null,
      "economic_impact": null,
      "ai_explanation": null
    }
  ],
  "timestamp": "2026-02-09T18:29:06.016194761+00:00",
  "security_score": 39,
  "deployment_advice": "DO NOT DEPLOY: 12 CRITICAL vulnerabilities found. Exploitation is highly likely.",
  "logic_invariants": [],
  "enhanced_report": {
    "base_report": {
      "summary": {
        "total_findings": 776,
        "critical_count": 380,
        "high_count": 340,
        "medium_count": 56,
        "low_count": 0,
        "overall_risk_score": 100,
        "top_vulnerability_types": [
          [
            "ManipulableSpotPrice",
            312
          ],
          [
            "MissingStalenessCheck",
            312
          ],
          [
            "DonationVulnerable",
            56
          ],
          [
            "FirstDepositInflation",
            56
          ],
          [
            "NoSlippageProtection",
            28
          ],
          [
            "FlashLoanReentrancy",
            11
          ],
          [
            "NonCanonicalBump",
            1
          ]
        ],
        "key_recommendations": [
          "URGENT: 380 critical vulnerabilities require immediate attention. Do not deploy until resolved.",
          "Multiple high-severity issues detected. Consider comprehensive security review.",
          "Add oracle staleness checks to 312 locations to prevent stale price exploitation."
        ]
      },
      "access_control_findings": [],
      "pda_findings": [
        {
          "derivation": {
            "name": "create_program_address_verify_pda",
            "location": "./programs/vulnerable-vault/src/pda_utils.rs",
            "line": 8,
            "derivation_type": "CreateProgramAddress",
            "seeds": [
              {
                "expression": "& [seeds , & [& [bump]]] . concat ()",
                "source": "Unknown",
                "is_validated": false
              },
              {
                "expression": "program_id",
                "source": "Unknown",
                "is_validated": false
              }
            ],
            "bump_source": "UserProvided",
            "program_id_source": "Unknown"
          },
          "vulnerability": "NonCanonicalBump",
          "severity": "Critical",
          "description": "User-provided bump at line 8 without canonical verification",
          "recommendation": "Use find_program_address to get canonical bump, then verify user bump matches",
          "attack_scenario": "Attacker provides different bump value that derives a PDA they control, enabling authority bypass or account substitution"
        }
      ],
      "flash_loan_findings": [
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 65 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "first_deposit_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "FirstDepositAttack",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Simple",
              "profit_potential": "High"
            }
          },
          "vulnerability": "FirstDepositInflation",
          "severity": "Critical",
          "description": "Share calculation at line 96 lacks first deposit protection. Attacker can inflate share price.",
          "attack_scenario": "1. Vault starts empty\n2. Attacker deposits 1 wei  gets 1 share\n3. Attacker donates large amount directly to vault\n4. Share price = large_amount / 1 share\n5. Victim deposits, gets 0 shares due to rounding\n6. Attacker withdraws with victim's deposit",
          "recommendation": "Lock minimum liquidity on first deposit (e.g., 1000 shares). Or require minimum first deposit amount. Check shares > 0 after calculation."
        },
        {
          "vector": {
            "name": "missing_slippage",
            "location": "swap function",
            "line": 0,
            "vector_type": "MissingSlippage",
            "price_dependencies": [],
            "manipulation_surface": {
              "capital_required": "Low",
              "complexity": "Simple",
              "profit_potential": "Medium"
            }
          },
          "vulnerability": "NoSlippageProtection",
          "severity": "High",
          "description": "No slippage protection found in swap/trade functions. Users vulnerable to sandwich attacks.",
          "attack_scenario": "1. Attacker monitors mempool for victim's swap\n2. Front-run: Execute large buy to pump price\n3. Victim's swap executes at inflated price\n4. Back-run: Sell tokens at high price\n5. Profit = victim's slippage",
          "recommendation": "Add min_amount_out parameter to swap functions:\nrequire!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded);"
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 65,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 65 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        },
        {
          "vector": {
            "name": "donation_attack",
            "location": "./programs/vulnerable-vault/src/secure_vault_mod.rs",
            "line": 96,
            "vector_type": "DonationAttack",
            "price_dependencies": [
              {
                "variable": "total_assets",
                "source": "AccountBalance",
                "usage": "SharePrice",
                "is_manipulable": true
              }
            ],
            "manipulation_surface": {
              "capital_required": "Medium",
              "complexity": "Moderate",
              "profit_potential": "High"
            }
          },
          "vulnerability": "DonationVulnerable",
          "severity": "Medium",
          "description": "Share calculation at line 96 may be vulnerable to donation attack if using direct balance reads.",
          "attack_scenario": "Attacker can donate tokens directly to vault to manipulate share price, potentially causing rounding errors that benefit them.",
          "recommendation": "Track deposits explicitly rather than using account balance. Or add virtual offset to prevent zero-state manipulation."
        }
      ],
      "oracle_findings": [
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 28 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 28,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 28. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 29 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 29,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 29. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 66 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_in . base.reserve_in",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 66,
            "oracle_type": "AMMSpot",
            "asset": "reserve_in",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 66. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "MissingStalenessCheck",
          "severity": "High",
          "description": "Oracle price read at line 67 lacks staleness validation. Outdated prices could be used for General.",
          "attack_scenario": "If oracle updates are delayed, protocol uses stale price. In volatile markets, this enables exploitation of outdated valuations.",
          "recommendation": "Add staleness check:\nlet max_age = 60; // seconds\nlet price = oracle.get_price_no_older_than(Clock::get()?.unix_timestamp, max_age)?;"
        },
        {
          "oracle_usage": {
            "name": "pool . reserve_out . base.reserve_out",
            "location": "./programs/vulnerable-vault/src/mev_defense_mod.rs",
            "line": 67,
            "oracle_type": "AMMSpot",
            "asset": "reserve_out",
            "usage_context": "General",
            "validations": []
          },
          "vulnerability": "ManipulableSpotPrice",
          "severity": "Critical",
          "description": "AMM spot price used at line 67. This is trivially manipulable within a single transaction via large swaps.",
          "attack_scenario": "1. Flash borrow tokens\n2. Swap to manipulate AMM price\n3. Exploit protocol using inflated/deflated price\n4. Reverse swap, repay loan, profit",
          "recommendation": "NEVER use AMM spot price for collateral or liquidations. Use Pyth/Switchboard external oracle. If using on-chain data, use TWAP over 30+ minutes."
        }
      ],
      "account_validation_findings": [],
      "privilege_findings": [],
      "reentrancy_findings": [
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "./programs/vulnerable-vault/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "./programs/vulnerable-vault/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "./programs/vulnerable-vault/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "./programs/vulnerable-vault/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "./programs/vulnerable-vault/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "./programs/vulnerable-vault/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "./programs/vulnerable-vault/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "./programs/vulnerable-vault/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "./programs/vulnerable-vault/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "./programs/vulnerable-vault/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        },
        {
          "vulnerability_type": "FlashLoanReentrancy",
          "severity": "Critical",
          "description": "Flash loan pattern without proper validation. Attacker can manipulate state during loan.",
          "recommendation": "Add invariant checks before and after flash loan execution.",
          "call_stack": [
            "flash loan pattern detected"
          ],
          "location": "./programs/vulnerable-vault/src/lib.rs",
          "function_name": "unknown",
          "cpi_target": null
        }
      ],
      "taint_findings": [],
      "cpi_findings": [],
      "dataflow_summary": {
        "total_definitions": 0,
        "total_uses": 0,
        "uninitialized_uses": 222,
        "dead_definitions": 144
      },
      "oracle_diversity": {
        "unique_sources": 1,
        "has_external_oracle": false,
        "has_proper_validation": false,
        "risk_level": "HIGH"
      },
      "files_analyzed": 12,
      "analysis_duration_ms": 263
    },
    "enhanced_taint": {
      "interprocedural_flows": 0,
      "context_sensitive_findings": 115,
      "field_sensitive_findings": 36,
      "path_sensitive_findings": 15,
      "backward_attack_paths": 0,
      "total_taint_sources": 0,
      "total_taint_sinks": 0,
      "flows": [],
      "backward_flows": []
    },
    "enhanced_dataflow": {
      "lamport_anomalies": [],
      "token_issues": [],
      "arithmetic_risks": [
        {
          "kind": "PotentialPrecisionLoss",
          "line": 65,
          "description": "Ensure division doesn't result in zero prematurely or check for remainders.",
          "severity": 3
        },
        {
          "kind": "PotentialPrecisionLoss",
          "line": 96,
          "description": "Ensure division doesn't result in zero prematurely or check for remainders.",
          "severity": 3
        }
      ],
      "total_operations": 0
    },
    "enhanced_cpi": {
      "findings": [],
      "program_id_sources": 0,
      "whitelist_checks": 0,
      "ownership_checks": 0,
      "high_risk_paths": 0
    },
    "enhanced_flash_loan": {
      "total_scenarios": 0,
      "high_risk_scenarios": 0,
      "scenarios": []
    },
    "enhanced_oracle": {
      "total_issues": 0,
      "critical_issues": 0,
      "circuit_breakers": [],
      "missing_protections": []
    },
    "enhanced_economic": null,
    "enhanced_summary": {
      "total_findings": 778,
      "coverage_percentage": 100.0,
      "attack_scenarios_count": 0,
      "cascade_protocols_analyzed": 0,
      "circuit_breakers_found": 0,
      "missing_protections": 0,
      "enhanced_risk_score": 100,
      "analysis_confidence": 0.95
    }
  },
  "total_value_at_risk_usd": 19464000.0,
  "scan_scope": [
    "Programs",
    "IDL",
    "Dependencies"
  ],
  "standards_compliance": {
    "Neodyme Checklist": [
      [
        "Signer verification on state changes",
        false
      ],
      [
        "Account ownership validation",
        true
      ]
    ],
    "Sec3 Practices": [
      [
        "Oracle staleness checks",
        false
      ]
    ]
  },
  "model_consensus": [
    [
      "Claude 3.5 Sonnet",
      true,
      "Primary pattern matching confirmed"
    ],
    [
      "GPT-4o",
      true,
      "State anomaly logic verified"
    ]
  ],
  "overall_risk_score": 6.006522,
  "technical_risk": 7.3695655,
  "financial_risk": 5.097826,
  "scan_command": "solana-security-swarm audit --prove",
  "network_status": "CONNECTED (mainnet-beta)"
}