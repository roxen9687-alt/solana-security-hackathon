//! Exploit Proof Generation and Verification
//!
//! Provides structured proofs of exploitability for discovered vulnerabilities.

use serde::{Deserialize, Serialize};

/// A complete exploit proof that demonstrates a vulnerability is exploitable
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitProof {
    /// Type of vulnerability proven
    pub vulnerability_type: VulnerabilityType,
    /// Concrete input values that trigger the vulnerability
    pub counterexample: Vec<(String, u64)>,
    /// Raw Z3 model output for debugging
    pub z3_model: String,
    /// Severity score (1-10)
    pub severity: u8,
    /// Name of the instruction containing the vulnerability
    pub instruction_name: String,
    /// Program ID affected
    pub program_id: String,
    /// Expected error code if vulnerability is triggered
    pub error_code: Option<u64>,
    /// Detailed explanation of the exploit
    pub explanation: String,
    /// Suggested fix
    pub mitigation: String,
    /// Attack prerequisites
    pub prerequisites: Vec<String>,
    /// Estimated financial impact if exploited
    pub estimated_impact: Option<ImpactEstimate>,

    // --- Economic Attack Fields ---
    pub oracle_price_before: Option<u64>,
    pub oracle_price_after: Option<u64>,
    pub vault_assets_before: Option<u64>,
    pub vault_shares_before: Option<u64>,
    pub attacker_profit_sol: Option<f64>,
}

impl ExploitProof {
    pub fn new(vulnerability_type: VulnerabilityType) -> Self {
        Self {
            vulnerability_type,
            counterexample: Vec::new(),
            z3_model: String::new(),
            severity: 5,
            instruction_name: String::new(),
            program_id: String::new(),
            error_code: None,
            explanation: String::new(),
            mitigation: String::new(),
            prerequisites: Vec::new(),
            estimated_impact: None,
            oracle_price_before: None,
            oracle_price_after: None,
            vault_assets_before: None,
            vault_shares_before: None,
            attacker_profit_sol: None,
        }
    }

    pub fn with_counterexample(mut self, name: &str, value: u64) -> Self {
        self.counterexample.push((name.to_string(), value));
        self
    }

    pub fn with_instruction(mut self, name: &str) -> Self {
        self.instruction_name = name.to_string();
        self
    }

    pub fn with_program(mut self, program_id: &str) -> Self {
        self.program_id = program_id.to_string();
        self
    }

    pub fn with_severity(mut self, severity: u8) -> Self {
        self.severity = severity.min(10);
        self
    }

    pub fn with_explanation(mut self, explanation: &str) -> Self {
        self.explanation = explanation.to_string();
        self
    }

    pub fn with_mitigation(mut self, mitigation: &str) -> Self {
        self.mitigation = mitigation.to_string();
        self
    }

    pub fn add_prerequisite(&mut self, prereq: &str) {
        self.prerequisites.push(prereq.to_string());
    }

    pub fn with_impact(mut self, impact: ImpactEstimate) -> Self {
        self.estimated_impact = Some(impact);
        self
    }

    /// Generate a human-readable summary
    pub fn summary(&self) -> String {
        format!(
            "[{:?}] {} in instruction '{}' (severity: {}/10)\n\
             Counterexample: {:?}\n\
             Mitigation: {}",
            self.vulnerability_type,
            self.explanation,
            self.instruction_name,
            self.severity,
            self.counterexample,
            self.mitigation
        )
    }

    /// Convert to JSON for reporting
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(self)
    }
}

/// Types of vulnerabilities that can be proven
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum VulnerabilityType {
    /// Arithmetic overflow/underflow
    ArithmeticOverflow(ArithmeticOpType),
    /// Authority bypass (unauthorized access)
    AuthorityBypass,
    /// Program invariant violation
    InvariantViolation(usize),
    /// Missing account validation
    MissingAccountValidation(AccountValidationType),
    /// Reentrancy vulnerability
    Reentrancy,
    /// Price manipulation
    PriceManipulation,
    /// Flash loan attack vector
    FlashLoanVulnerability,
    /// Token validation issue
    TokenMintMismatch,
    /// Missing signer check
    MissingSignerCheck,
    /// PDA derivation mismatch
    PDAMismatch,
    /// Insufficient balance check
    InsufficientBalanceCheck,
    /// Improper lamport handling
    LamportHandling,
    /// Oracle manipulation
    OracleManipulation,
    /// Division by zero
    DivisionByZero,
}

impl VulnerabilityType {
    pub fn severity_base(&self) -> u8 {
        match self {
            Self::AuthorityBypass => 9,
            Self::Reentrancy => 9,
            Self::PriceManipulation => 8,
            Self::FlashLoanVulnerability => 8,
            Self::ArithmeticOverflow(_) => 7,
            Self::TokenMintMismatch => 7,
            Self::MissingSignerCheck => 8,
            Self::PDAMismatch => 7,
            Self::MissingAccountValidation(_) => 6,
            Self::InvariantViolation(_) => 5,
            Self::InsufficientBalanceCheck => 6,
            Self::LamportHandling => 5,
            Self::OracleManipulation => 8,
            Self::DivisionByZero => 6,
        }
    }

    pub fn description(&self) -> &'static str {
        match self {
            Self::AuthorityBypass => "Unauthorized user can execute privileged operations",
            Self::Reentrancy => "State can be exploited through reentrant calls",
            Self::PriceManipulation => "Asset prices can be manipulated",
            Self::FlashLoanVulnerability => "Protocol is vulnerable to flash loan attacks",
            Self::ArithmeticOverflow(_) => "Integer overflow/underflow can occur",
            Self::TokenMintMismatch => "Token mint validation is missing or incorrect",
            Self::MissingSignerCheck => "Operation proceeds without required signature",
            Self::PDAMismatch => "PDA validation can be bypassed",
            Self::MissingAccountValidation(_) => "Account validation is missing",
            Self::InvariantViolation(_) => "Program invariant can be violated",
            Self::InsufficientBalanceCheck => "Balance check is missing or incorrect",
            Self::LamportHandling => "Lamport balance handling is incorrect",
            Self::OracleManipulation => "Oracle price feed can be manipulated",
            Self::DivisionByZero => "Division by zero is possible",
        }
    }
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum ArithmeticOpType {
    Add,
    Sub,
    Mul,
    Div,
}

impl ArithmeticOpType {
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Add => "addition",
            Self::Sub => "subtraction",
            Self::Mul => "multiplication",
            Self::Div => "division",
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AccountValidationType {
    OwnerCheck,
    SignerCheck,
    WritableCheck,
    InitializedCheck,
    KeyCheck,
}

/// Estimated financial impact
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImpactEstimate {
    /// Minimum potential loss in SOL
    pub min_loss_sol: Option<f64>,
    /// Maximum potential loss in SOL
    pub max_loss_sol: Option<f64>,
    /// Whether loss is bounded
    pub is_bounded: bool,
    /// Impact description
    pub description: String,
}

impl ImpactEstimate {
    pub fn unbounded(description: &str) -> Self {
        Self {
            min_loss_sol: None,
            max_loss_sol: None,
            is_bounded: false,
            description: description.to_string(),
        }
    }

    pub fn bounded(min: f64, max: f64, description: &str) -> Self {
        Self {
            min_loss_sol: Some(min),
            max_loss_sol: Some(max),
            is_bounded: true,
            description: description.to_string(),
        }
    }
}

/// Collection of exploit proofs for a program
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitReport {
    pub program_id: String,
    pub timestamp: String,
    pub proofs: Vec<ExploitProof>,
    pub total_severity: u32,
    pub summary: String,
}

impl ExploitReport {
    pub fn new(program_id: &str) -> Self {
        Self {
            program_id: program_id.to_string(),
            timestamp: chrono::Utc::now().to_rfc3339(),
            proofs: Vec::new(),
            total_severity: 0,
            summary: String::new(),
        }
    }

    pub fn add_proof(&mut self, proof: ExploitProof) {
        self.total_severity += proof.severity as u32;
        self.proofs.push(proof);
    }

    pub fn generate_summary(&mut self) {
        let critical = self.proofs.iter().filter(|p| p.severity >= 8).count();
        let high = self
            .proofs
            .iter()
            .filter(|p| p.severity >= 6 && p.severity < 8)
            .count();
        let medium = self
            .proofs
            .iter()
            .filter(|p| p.severity >= 4 && p.severity < 6)
            .count();
        let low = self.proofs.iter().filter(|p| p.severity < 4).count();

        self.summary = format!(
            "Found {} vulnerabilities: {} critical, {} high, {} medium, {} low",
            self.proofs.len(),
            critical,
            high,
            medium,
            low
        );
    }

    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(self)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_exploit_proof_builder() {
        let proof = ExploitProof::new(VulnerabilityType::ArithmeticOverflow(ArithmeticOpType::Add))
            .with_counterexample("amount", u64::MAX - 10)
            .with_counterexample("fee", 20)
            .with_instruction("transfer")
            .with_program("TokenProgram")
            .with_severity(7)
            .with_explanation("Adding amount and fee causes overflow")
            .with_mitigation("Use checked_add instead of +");

        assert_eq!(proof.severity, 7);
        assert_eq!(proof.counterexample.len(), 2);
        assert!(proof.summary().contains("overflow"));
    }

    #[test]
    fn test_exploit_report() {
        let mut report = ExploitReport::new("11111111111111111111111111111111");

        report.add_proof(ExploitProof::new(VulnerabilityType::AuthorityBypass).with_severity(9));
        report.add_proof(ExploitProof::new(VulnerabilityType::MissingSignerCheck).with_severity(8));

        report.generate_summary();

        assert_eq!(report.proofs.len(), 2);
        assert!(report.summary.contains("critical"));
    }
}
