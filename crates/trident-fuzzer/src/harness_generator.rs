//! Trident Fuzz Harness Generator
//!
//! Automatically generates Trident-compatible fuzz test code from the
//! extracted `AnchorProgramModel`. Produces:
//! - Main fuzz test with `#[init]` and `#[flow]` macros
//! - Property invariant checks (balance conservation, access control, etc.)
//! - Multi-instruction attack flow sequences

use crate::anchor_extractor::{AnchorInstruction, AnchorProgramModel};
use std::path::Path;

/// Generates Trident fuzz harness source code.
pub struct TridentHarnessGenerator {
    _private: (),
}

impl TridentHarnessGenerator {
    pub fn new() -> Self {
        Self { _private: () }
    }

    /// Generate the main Trident fuzz test file.
    ///
    /// This file contains:
    /// - Account/FuzzAccounts struct definitions
    /// - `#[init]` function for program initialization
    /// - `#[flow]` functions for each instruction with randomized inputs
    /// - Property checks after each flow
    pub fn generate_fuzz_test(&self, model: &AnchorProgramModel) -> String {
        let mut code = String::new();

        // Header
        code.push_str(&format!(
            "//! Auto-generated Trident fuzz test for '{}'\n\
             //! Generated by Solana Security Swarm — Trident Integration\n\
             //!\n\
             //! Run with: trident fuzz run fuzz_test\n\n",
            model.program_name,
        ));

        // Imports
        code.push_str("use trident_fuzz::prelude::*;\n");
        code.push_str("use anchor_lang::prelude::*;\n\n");

        // FuzzAccounts struct
        code.push_str("/// Fuzz account storage for the fuzzing campaign.\n");
        code.push_str("#[derive(Default)]\n");
        code.push_str("pub struct FuzzAccounts {\n");

        let mut seen_accounts = std::collections::HashSet::new();
        for account in &model.accounts {
            if seen_accounts.insert(account.name.clone()) {
                code.push_str(&format!("    pub {}: AccountId,\n", account.name,));
            }
        }
        code.push_str("}\n\n");

        // Fuzz Test struct
        code.push_str("#[derive(Default)]\n");
        code.push_str("pub struct FuzzTest {\n");
        code.push_str("    pub trident: TridentSVM,\n");
        code.push_str("    pub fuzz_accounts: FuzzAccounts,\n");
        code.push_str("}\n\n");

        // Init function — build initialization transactions
        let init_instructions: Vec<&AnchorInstruction> = model
            .instructions
            .iter()
            .filter(|ix| {
                ix.name.contains("init")
                    || ix.name.contains("create")
                    || ix.name.contains("register")
            })
            .collect();

        code.push_str("impl FuzzTest {\n");
        code.push_str("    /// Initialize program state before fuzzing begins.\n");
        code.push_str("    #[init]\n");
        code.push_str("    fn start(&mut self) {\n");

        if init_instructions.is_empty() {
            code.push_str(
                "        // No initialization instruction found — program may not require init\n",
            );
            code.push_str("        tracing::info!(\"Fuzz test initialized without explicit init instruction\");\n");
        } else {
            for ix in &init_instructions {
                let tx_name = to_pascal_case(&ix.name);
                code.push_str(&format!("        // Initialize via '{}'\n", ix.name,));
                code.push_str(&format!(
                    "        let mut tx = {}Transaction::build(&mut self.trident, &mut self.fuzz_accounts);\n",
                    tx_name,
                ));
                code.push_str(&format!(
                    "        self.trident.execute_transaction(&mut tx, Some(\"{}\"));\n\n",
                    ix.name,
                ));
            }
        }
        code.push_str("    }\n\n");

        // Flow functions — one per non-init instruction
        for ix in &model.instructions {
            if init_instructions.iter().any(|init| init.name == ix.name) {
                continue; // skip init instructions, already in #[init]
            }

            let tx_name = to_pascal_case(&ix.name);
            code.push_str(&format!(
                "    /// Fuzz flow for instruction '{}'\n",
                ix.name,
            ));
            code.push_str("    #[flow]\n");
            code.push_str(&format!(
                "    fn flow_{}(&mut self) {{\n",
                ix.name.to_lowercase(),
            ));

            // Build transaction with fuzzed inputs
            code.push_str(&format!(
                "        let mut tx = {}Transaction::build(\n",
                tx_name,
            ));
            code.push_str("            &mut self.trident,\n");
            code.push_str("            &mut self.fuzz_accounts,\n");
            code.push_str("        );\n");

            // Randomize parameters if the instruction has any
            for (param_name, param_type) in &ix.parameters {
                let random_expr = self.random_value_for_type(param_type);
                code.push_str(&format!(
                    "        tx.set_{}({});\n",
                    param_name, random_expr,
                ));
            }

            code.push_str(&format!(
                "        self.trident.execute_transaction(&mut tx, Some(\"{}\"));\n",
                ix.name,
            ));

            // Add property checks after execution
            if ix.has_transfer {
                code.push_str("\n        // Property: balance conservation check\n");
                code.push_str(
                    "        // assert!(pre_balance >= post_balance || authorized_mint);\n",
                );
            }

            if ix.has_arithmetic {
                code.push_str("\n        // Property: no arithmetic overflow\n");
                code.push_str("        // Trident monitors for panics from unchecked math\n");
            }

            code.push_str("    }\n\n");
        }

        code.push_str("}\n");
        code
    }

    /// Generate property invariant checks.
    pub fn generate_invariant_checks(&self, model: &AnchorProgramModel) -> String {
        let mut code = String::new();

        code.push_str(&format!(
            "//! Property invariants for '{}'\n\
             //! These checks run after every fuzz flow to verify program correctness.\n\n",
            model.program_name,
        ));

        code.push_str("use trident_fuzz::prelude::*;\n\n");

        // Balance conservation invariant
        code.push_str("/// Invariant: No tokens created from nothing.\n");
        code.push_str(
            "/// After any instruction, total supply must not increase without a mint.\n",
        );
        code.push_str("pub fn check_balance_conservation(\n");
        code.push_str("    pre_state: &AccountsSnapshot,\n");
        code.push_str("    post_state: &AccountsSnapshot,\n");
        code.push_str(") -> InvariantResult {\n");
        code.push_str("    let pre_total: u64 = pre_state.token_balances().values().sum();\n");
        code.push_str("    let post_total: u64 = post_state.token_balances().values().sum();\n");
        code.push_str("    if post_total > pre_total {\n");
        code.push_str("        InvariantResult::Violated(format!(\n");
        code.push_str("            \"Balance conservation violated: {} -> {} (delta: +{})\",\n");
        code.push_str("            pre_total, post_total, post_total - pre_total,\n");
        code.push_str("        ))\n");
        code.push_str("    } else {\n");
        code.push_str("        InvariantResult::Held\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");

        // Access control invariant
        code.push_str("/// Invariant: State mutations require authorized signer.\n");
        code.push_str("pub fn check_access_control(\n");
        code.push_str("    tx_result: &TransactionResult,\n");
        code.push_str("    expected_signer: &Pubkey,\n");
        code.push_str(") -> InvariantResult {\n");
        code.push_str(
            "    if tx_result.succeeded() && !tx_result.signers().contains(expected_signer) {\n",
        );
        code.push_str("        InvariantResult::Violated(format!(\n");
        code.push_str("            \"State mutation succeeded without expected signer: {}\",\n");
        code.push_str("            expected_signer,\n");
        code.push_str("        ))\n");
        code.push_str("    } else {\n");
        code.push_str("        InvariantResult::Held\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");

        // Discriminator integrity
        code.push_str(
            "/// Invariant: Account discriminators must not change after initialization.\n",
        );
        code.push_str("pub fn check_discriminator_integrity(\n");
        code.push_str("    pre_state: &AccountsSnapshot,\n");
        code.push_str("    post_state: &AccountsSnapshot,\n");
        code.push_str(") -> InvariantResult {\n");
        code.push_str("    for (key, pre_data) in pre_state.account_data() {\n");
        code.push_str("        if let Some(post_data) = post_state.account_data().get(key) {\n");
        code.push_str("            if pre_data.len() >= 8 && post_data.len() >= 8 {\n");
        code.push_str("                if pre_data[..8] != post_data[..8] {\n");
        code.push_str("                    return InvariantResult::Violated(format!(\n");
        code.push_str("                        \"Discriminator changed for account {}\", key,\n");
        code.push_str("                    ));\n");
        code.push_str("                }\n");
        code.push_str("            }\n");
        code.push_str("        }\n");
        code.push_str("    }\n");
        code.push_str("    InvariantResult::Held\n");
        code.push_str("}\n\n");

        // PDA derivation integrity
        if !model.pda_derivations.is_empty() {
            code.push_str("/// Invariant: PDA addresses must be derived from canonical bumps.\n");
            code.push_str("pub fn check_pda_canonical_bump(\n");
            code.push_str("    pda_address: &Pubkey,\n");
            code.push_str("    seeds: &[&[u8]],\n");
            code.push_str("    program_id: &Pubkey,\n");
            code.push_str(") -> InvariantResult {\n");
            code.push_str(
                "    let (expected, _bump) = Pubkey::find_program_address(seeds, program_id);\n",
            );
            code.push_str("    if pda_address != &expected {\n");
            code.push_str("        InvariantResult::Violated(format!(\n");
            code.push_str("            \"PDA address mismatch: got {}, expected {}\",\n");
            code.push_str("            pda_address, expected,\n");
            code.push_str("        ))\n");
            code.push_str("    } else {\n");
            code.push_str("        InvariantResult::Held\n");
            code.push_str("    }\n");
            code.push_str("}\n");
        }

        code
    }

    /// Generate multi-instruction attack flow sequences.
    pub fn generate_flow_sequences(&self, model: &AnchorProgramModel) -> String {
        let mut code = String::new();

        code.push_str(&format!(
            "//! Attack flow sequences for '{}'\n\
             //! Multi-instruction patterns that model real-world attack scenarios.\n\n",
            model.program_name,
        ));

        code.push_str("use trident_fuzz::prelude::*;\n\n");

        // Double-spend attack flow
        let transfer_ixs: Vec<&AnchorInstruction> = model
            .instructions
            .iter()
            .filter(|ix| ix.has_transfer)
            .collect();

        if !transfer_ixs.is_empty() {
            code.push_str("/// Attack Flow: Double-Spend Attempt\n");
            code.push_str("/// Tries to execute the same transfer twice in rapid succession.\n");
            code.push_str("pub fn attack_double_spend(trident: &mut TridentSVM, accounts: &mut FuzzAccounts) {\n");
            for ix in &transfer_ixs {
                let tx_name = to_pascal_case(&ix.name);
                code.push_str(&format!(
                    "    let mut tx1 = {}Transaction::build(trident, accounts);\n",
                    tx_name,
                ));
                code.push_str(
                    "    trident.execute_transaction(&mut tx1, Some(\"double_spend_1\"));\n",
                );
                code.push_str(&format!(
                    "    let mut tx2 = {}Transaction::build(trident, accounts);\n",
                    tx_name,
                ));
                code.push_str(
                    "    trident.execute_transaction(&mut tx2, Some(\"double_spend_2\"));\n\n",
                );
            }
            code.push_str("}\n\n");
        }

        // Init → drain attack flow
        let init_ixs: Vec<&AnchorInstruction> = model
            .instructions
            .iter()
            .filter(|ix| ix.name.contains("init") || ix.name.contains("create"))
            .collect();
        let close_ixs: Vec<&AnchorInstruction> = model
            .instructions
            .iter()
            .filter(|ix| ix.name.contains("close") || ix.name.contains("withdraw"))
            .collect();

        if !init_ixs.is_empty() && !close_ixs.is_empty() {
            code.push_str("/// Attack Flow: Init → Close → Re-Init (Re-initialization Attack)\n");
            code.push_str("/// Initializes, closes, and re-initializes to steal lamports.\n");
            code.push_str("pub fn attack_reinit_drain(trident: &mut TridentSVM, accounts: &mut FuzzAccounts) {\n");
            for init_ix in &init_ixs {
                let init_name = to_pascal_case(&init_ix.name);
                code.push_str(&format!(
                    "    let mut init = {}Transaction::build(trident, accounts);\n",
                    init_name,
                ));
                code.push_str("    trident.execute_transaction(&mut init, Some(\"init\"));\n\n");
            }
            for close_ix in &close_ixs {
                let close_name = to_pascal_case(&close_ix.name);
                code.push_str(&format!(
                    "    let mut close = {}Transaction::build(trident, accounts);\n",
                    close_name,
                ));
                code.push_str("    trident.execute_transaction(&mut close, Some(\"close\"));\n\n");
            }
            // Re-init after close
            for init_ix in &init_ixs {
                let init_name = to_pascal_case(&init_ix.name);
                code.push_str("    // Re-initialize after close — this should FAIL\n");
                code.push_str(&format!(
                    "    let mut reinit = {}Transaction::build(trident, accounts);\n",
                    init_name,
                ));
                code.push_str(
                    "    trident.execute_transaction(&mut reinit, Some(\"reinit_attack\"));\n\n",
                );
            }
            code.push_str("}\n\n");
        }

        // Privilege escalation flow: call admin functions without signer
        let admin_ixs: Vec<&AnchorInstruction> = model
            .instructions
            .iter()
            .filter(|ix| {
                ix.name.contains("admin") || ix.name.contains("update") || ix.name.contains("set")
            })
            .collect();

        if !admin_ixs.is_empty() {
            code.push_str("/// Attack Flow: Privilege Escalation\n");
            code.push_str("/// Attempts to call admin functions with non-admin accounts.\n");
            code.push_str("pub fn attack_privilege_escalation(trident: &mut TridentSVM, accounts: &mut FuzzAccounts) {\n");
            for ix in &admin_ixs {
                let tx_name = to_pascal_case(&ix.name);
                code.push_str(&format!(
                    "    // Call '{}' with a random (non-admin) keypair\n",
                    ix.name,
                ));
                code.push_str("    let attacker = Keypair::new();\n");
                code.push_str(&format!(
                    "    let mut tx = {}Transaction::build_with_signer(trident, accounts, &attacker);\n",
                    tx_name,
                ));
                code.push_str(&format!(
                    "    let result = trident.execute_transaction(&mut tx, Some(\"priv_esc_{}\"));\n",
                    ix.name,
                ));
                code.push_str(&format!(
                    "    assert!(result.is_err(), \"Admin function '{}' accepted non-admin signer!\");\n\n",
                    ix.name,
                ));
            }
            code.push_str("}\n\n");
        }

        code
    }

    /// Generate Cargo.toml for the fuzz harness crate.
    pub fn generate_cargo_toml(&self, model: &AnchorProgramModel, program_path: &Path) -> String {
        let prog_name = if model.program_name.is_empty() {
            program_path
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("unknown")
                .to_string()
        } else {
            model.program_name.clone()
        };

        format!(
            r#"[package]
name = "trident_fuzz_{name}"
version = "0.1.0"
edition = "2021"

[dependencies]
trident-client = "0.12"
trident-fuzz = "0.2"
anchor-lang = "0.30"
"#,
            name = prog_name.replace('-', "_"),
        )
    }

    /// Get a random value expression for a Rust type.
    fn random_value_for_type(&self, ty: &str) -> String {
        match ty.trim() {
            "u8" => "rand::random::<u8>()".into(),
            "u16" => "rand::random::<u16>()".into(),
            "u32" => "rand::random::<u32>()".into(),
            "u64" => "rand::random::<u64>()".into(),
            "u128" => "rand::random::<u128>()".into(),
            "i8" => "rand::random::<i8>()".into(),
            "i16" => "rand::random::<i16>()".into(),
            "i32" => "rand::random::<i32>()".into(),
            "i64" => "rand::random::<i64>()".into(),
            "i128" => "rand::random::<i128>()".into(),
            "bool" => "rand::random::<bool>()".into(),
            "String" => "format!(\"fuzz_{}\", rand::random::<u32>())".into(),
            _ if ty.contains("Pubkey") => "Pubkey::new_unique()".into(),
            _ => format!("Default::default() /* {} */", ty),
        }
    }
}

impl Default for TridentHarnessGenerator {
    fn default() -> Self {
        Self::new()
    }
}

/// Convert `snake_case` to `PascalCase`.
fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}
