//! WASM/SBF vulnerability detectors.
//!
//! Each detector implements a specific class of on-chain data vulnerability
//! and operates on concolic execution states.

use crate::concolic_engine::ConcolicState;
use crate::report::{WacanaFinding, WacanaSeverity};
use crate::sbf_decoder::{SbfEntryPoint, SbfModule};
use crate::wasm_parser::{WasmFunction, WasmInstruction, WasmModule};
use serde::{Deserialize, Serialize};

/// Vulnerability category for WACANA findings.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum VulnerabilityCategory {
    MemorySafety,
    TypeConfusion,
    IndirectCallViolation,
    LinearMemoryOverflow,
    UninitializedData,
    ReentrancyPattern,
    IntegerOverflow,
    DivisionByZero,
    UnboundedLoop,
    MissingBoundsCheck,
    UncheckedExternalData,
}

/// Vulnerability severity for WASM-specific issues.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum WasmVulnerabilitySeverity {
    Critical = 5,
    High = 4,
    Medium = 3,
    Low = 2,
    Info = 1,
}

/// A vulnerability detected in WASM bytecode or SBF binary.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WasmVulnerability {
    pub category: VulnerabilityCategory,
    pub severity: WasmVulnerabilitySeverity,
    pub description: String,
    pub location: String,
    pub details: Option<String>,
}

/// Trait for all vulnerability detectors.
pub trait VulnerabilityDetector: Send + Sync {
    /// Check a WASM concolic state for vulnerabilities.
    fn check_wasm_state(
        &self,
        state: &ConcolicState,
        func: &WasmFunction,
        module: &WasmModule,
    ) -> Vec<WacanaFinding>;

    /// Check an SBF concolic state for vulnerabilities.
    fn check_sbf_state(
        &self,
        state: &ConcolicState,
        entry: &SbfEntryPoint,
        module: &SbfModule,
    ) -> Vec<WacanaFinding>;

    /// Detector name.
    fn name(&self) -> &str;
}

// ─── Memory Safety Detector ─────────────────────────────────────────────────

pub struct MemorySafetyDetector;

impl Default for MemorySafetyDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl MemorySafetyDetector {
    pub fn new() -> Self {
        Self
    }
}

impl VulnerabilityDetector for MemorySafetyDetector {
    fn check_wasm_state(
        &self,
        state: &ConcolicState,
        func: &WasmFunction,
        module: &WasmModule,
    ) -> Vec<WacanaFinding> {
        let mut findings = Vec::new();
        let memory_bound = (module.memory.initial_pages as u64) * 65536;

        for access in &state.memory_accesses {
            // Out-of-bounds access
            if access.address + access.size as u64 > memory_bound {
                findings.push(WacanaFinding {
                    category: VulnerabilityCategory::MemorySafety,
                    severity: WacanaSeverity::Critical,
                    location: format!(
                        "func_{}:{} (memory access at 0x{:x}, size {})",
                        func.index, access.instruction_offset, access.address, access.size
                    ),
                    description: format!(
                        "Out-of-bounds memory {} at address 0x{:x} (bound: 0x{:x}). \
                         An attacker could read/write beyond linear memory to corrupt program state or leak secrets.",
                        if access.is_write { "write" } else { "read" },
                        access.address,
                        memory_bound,
                    ),
                    triggering_input: format_concrete_inputs(&state.concrete_values),
                    path_constraints: state.path_constraints.iter().map(|c| c.expression.clone()).collect(),
                    recommendation: "Add explicit bounds checks before all memory accesses. Use safe wrappers for memory operations.".to_string(),
                    fingerprint: String::new(),
                    cwe: Some("CWE-787".to_string()),
                    concolic_proof: Some(format!(
                        "Concolic execution reached OOB access at pc={} with inputs: {:?}",
                        access.instruction_offset, state.concrete_values
                    )),
                });
            }

            // Near-boundary access (within 16 bytes of memory bound)
            if access.address + access.size as u64 <= memory_bound
                && access.address + access.size as u64 + 16 > memory_bound
                && memory_bound > 0
            {
                findings.push(WacanaFinding {
                    category: VulnerabilityCategory::MissingBoundsCheck,
                    severity: WacanaSeverity::Medium,
                    location: format!(
                        "func_{}:{} (near-boundary access at 0x{:x})",
                        func.index, access.instruction_offset, access.address,
                    ),
                    description: format!(
                        "Memory access at 0x{:x} is within 16 bytes of linear memory boundary (0x{:x}). \
                         Slightly different inputs could cause an out-of-bounds access.",
                        access.address, memory_bound,
                    ),
                    triggering_input: format_concrete_inputs(&state.concrete_values),
                    path_constraints: state.path_constraints.iter().map(|c| c.expression.clone()).collect(),
                    recommendation: "Add defensive bounds checking with sufficient margin.".to_string(),
                    fingerprint: String::new(),
                    cwe: Some("CWE-120".to_string()),
                    concolic_proof: None,
                });
            }
        }

        findings
    }

    fn check_sbf_state(
        &self,
        state: &ConcolicState,
        entry: &SbfEntryPoint,
        _module: &SbfModule,
    ) -> Vec<WacanaFinding> {
        let mut findings = Vec::new();

        // SBF has specific memory regions; check for stack overflow patterns
        for access in &state.memory_accesses {
            // Stack grows downward from r10; check for underflow
            let r10 = state
                .concrete_values
                .get("r10")
                .copied()
                .unwrap_or(0x200000000);
            let stack_bottom = r10 as u64 - 4096; // Typical SBF stack size

            if access.address < stack_bottom && access.is_write {
                findings.push(WacanaFinding {
                    category: VulnerabilityCategory::MemorySafety,
                    severity: WacanaSeverity::Critical,
                    location: format!(
                        "{}:+{} (write at 0x{:x}, stack bottom ~0x{:x})",
                        entry.name, access.instruction_offset, access.address, stack_bottom
                    ),
                    description: format!(
                        "Potential SBF stack buffer overflow: write at 0x{:x} underflows stack \
                         (r10=0x{:x}, estimated stack bottom=0x{:x}).",
                        access.address, r10, stack_bottom
                    ),
                    triggering_input: format_concrete_inputs(&state.concrete_values),
                    path_constraints: state
                        .path_constraints
                        .iter()
                        .map(|c| c.expression.clone())
                        .collect(),
                    recommendation:
                        "Ensure stack allocations are bounded and do not exceed SBF stack limits."
                            .to_string(),
                    fingerprint: String::new(),
                    cwe: Some("CWE-121".to_string()),
                    concolic_proof: Some(format!(
                        "SBF concolic execution triggered stack overflow at offset {}",
                        access.instruction_offset
                    )),
                });
            }
        }

        findings
    }

    fn name(&self) -> &str {
        "MemorySafety"
    }
}

// ─── Type Confusion Detector ────────────────────────────────────────────────

pub struct TypeConfusionDetector;

impl Default for TypeConfusionDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl TypeConfusionDetector {
    pub fn new() -> Self {
        Self
    }
}

impl VulnerabilityDetector for TypeConfusionDetector {
    fn check_wasm_state(
        &self,
        state: &ConcolicState,
        func: &WasmFunction,
        _module: &WasmModule,
    ) -> Vec<WacanaFinding> {
        let mut findings = Vec::new();

        // Check for indirect calls to unexpected function types
        for call in &state.indirect_calls {
            // If the function index is negative or very large, it's suspect
            if call.function_index < 0 || call.function_index > 65535 {
                findings.push(WacanaFinding {
                    category: VulnerabilityCategory::TypeConfusion,
                    severity: WacanaSeverity::Critical,
                    location: format!(
                        "func_{}:{} (call_indirect table={}, idx={})",
                        func.index, call.instruction_offset, call.table_index, call.function_index
                    ),
                    description: format!(
                        "Indirect call with suspicious function index {}. This may indicate \
                         type confusion, allowing an attacker to redirect control flow to \
                         unintended functions.",
                        call.function_index,
                    ),
                    triggering_input: format_concrete_inputs(&state.concrete_values),
                    path_constraints: state
                        .path_constraints
                        .iter()
                        .map(|c| c.expression.clone())
                        .collect(),
                    recommendation:
                        "Validate call_indirect targets against expected function types at runtime."
                            .to_string(),
                    fingerprint: String::new(),
                    cwe: Some("CWE-843".to_string()),
                    concolic_proof: Some(format!(
                        "Concolic execution produced call_indirect index={} at func_{}:{}",
                        call.function_index, func.index, call.instruction_offset
                    )),
                });
            }
        }

        findings
    }

    fn check_sbf_state(
        &self,
        _state: &ConcolicState,
        _entry: &SbfEntryPoint,
        _module: &SbfModule,
    ) -> Vec<WacanaFinding> {
        // SBF doesn't have type confusion in the WASM sense, but it can
        // have account type confusion (deserializing wrong account type)
        Vec::new()
    }

    fn name(&self) -> &str {
        "TypeConfusion"
    }
}

// ─── Indirect Call Detector ─────────────────────────────────────────────────

pub struct IndirectCallDetector;

impl Default for IndirectCallDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl IndirectCallDetector {
    pub fn new() -> Self {
        Self
    }
}

impl VulnerabilityDetector for IndirectCallDetector {
    fn check_wasm_state(
        &self,
        state: &ConcolicState,
        func: &WasmFunction,
        module: &WasmModule,
    ) -> Vec<WacanaFinding> {
        let mut findings = Vec::new();

        for call in &state.indirect_calls {
            // Check if the call target is within the valid table range
            let table = module.tables.get(call.table_index as usize);
            let max_size = table
                .map(|t| t.max_size.unwrap_or(t.initial_size) as i64)
                .unwrap_or(0);

            if call.function_index >= max_size || call.function_index < 0 {
                findings.push(WacanaFinding {
                    category: VulnerabilityCategory::IndirectCallViolation,
                    severity: WacanaSeverity::High,
                    location: format!(
                        "func_{}:{} (table {} bounds: 0..{})",
                        func.index, call.instruction_offset, call.table_index, max_size
                    ),
                    description: format!(
                        "call_indirect target index {} is out of table bounds (table size: {}). \
                         In WASM, this traps at runtime, but in some WASM-on-Solana runtimes, \
                         bounds checking may be incomplete.",
                        call.function_index, max_size,
                    ),
                    triggering_input: format_concrete_inputs(&state.concrete_values),
                    path_constraints: state
                        .path_constraints
                        .iter()
                        .map(|c| c.expression.clone())
                        .collect(),
                    recommendation:
                        "Explicitly validate indirect call target indices before invocation."
                            .to_string(),
                    fingerprint: String::new(),
                    cwe: Some("CWE-129".to_string()),
                    concolic_proof: Some(format!(
                        "Z3 found inputs causing OOB indirect call: idx={}, table_size={}",
                        call.function_index, max_size
                    )),
                });
            }
        }

        findings
    }

    fn check_sbf_state(
        &self,
        _state: &ConcolicState,
        _entry: &SbfEntryPoint,
        _module: &SbfModule,
    ) -> Vec<WacanaFinding> {
        Vec::new()
    }

    fn name(&self) -> &str {
        "IndirectCall"
    }
}

// ─── Linear Memory Overflow Detector ────────────────────────────────────────

pub struct LinearMemoryOverflowDetector;

impl Default for LinearMemoryOverflowDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl LinearMemoryOverflowDetector {
    pub fn new() -> Self {
        Self
    }
}

impl VulnerabilityDetector for LinearMemoryOverflowDetector {
    fn check_wasm_state(
        &self,
        state: &ConcolicState,
        func: &WasmFunction,
        module: &WasmModule,
    ) -> Vec<WacanaFinding> {
        let mut findings = Vec::new();
        let memory_bound = (module.memory.initial_pages as u64) * 65536;

        // Look for patterns where attacker-controlled values are used as memory offsets
        for access in &state.memory_accesses {
            if access.is_write && access.address > memory_bound / 2 {
                // If writing to the upper half of memory with user-controlled offset,
                // there's a risk of corrupting critical data structures stored there
                findings.push(WacanaFinding {
                    category: VulnerabilityCategory::LinearMemoryOverflow,
                    severity: WacanaSeverity::High,
                    location: format!(
                        "func_{}:{} (write at 0x{:x}, upper memory region)",
                        func.index, access.instruction_offset, access.address
                    ),
                    description: format!(
                        "Write to upper linear memory (0x{:x}) using potentially attacker-controlled offset. \
                         WASM linear memory often stores critical data structures (heap metadata, \
                         account data) in upper regions. Overwriting these can lead to privilege escalation.",
                        access.address,
                    ),
                    triggering_input: format_concrete_inputs(&state.concrete_values),
                    path_constraints: state.path_constraints.iter().map(|c| c.expression.clone()).collect(),
                    recommendation: "Validate all memory write offsets against expected data region boundaries.".to_string(),
                    fingerprint: String::new(),
                    cwe: Some("CWE-787".to_string()),
                    concolic_proof: None,
                });
            }
        }

        findings
    }

    fn check_sbf_state(
        &self,
        _state: &ConcolicState,
        _entry: &SbfEntryPoint,
        _module: &SbfModule,
    ) -> Vec<WacanaFinding> {
        Vec::new()
    }

    fn name(&self) -> &str {
        "LinearMemoryOverflow"
    }
}

// ─── Uninitialized Data Detector ────────────────────────────────────────────

pub struct UninitializedDataDetector;

impl Default for UninitializedDataDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl UninitializedDataDetector {
    pub fn new() -> Self {
        Self
    }
}

impl VulnerabilityDetector for UninitializedDataDetector {
    fn check_wasm_state(
        &self,
        state: &ConcolicState,
        func: &WasmFunction,
        _module: &WasmModule,
    ) -> Vec<WacanaFinding> {
        let mut findings = Vec::new();

        // Track which memory addresses have been written to
        let mut written_addresses: std::collections::HashSet<u64> =
            std::collections::HashSet::new();
        let mut read_before_write = Vec::new();

        for access in &state.memory_accesses {
            if access.is_write {
                for i in 0..access.size {
                    written_addresses.insert(access.address + i as u64);
                }
            } else {
                // Check if any byte in this read range was not previously written
                let mut has_uninit = false;
                for i in 0..access.size {
                    if !written_addresses.contains(&(access.address + i as u64)) {
                        has_uninit = true;
                        break;
                    }
                }
                if has_uninit {
                    read_before_write.push(access.clone());
                }
            }
        }

        for access in &read_before_write {
            findings.push(WacanaFinding {
                category: VulnerabilityCategory::UninitializedData,
                severity: WacanaSeverity::High,
                location: format!(
                    "func_{}:{} (read at 0x{:x} before write)",
                    func.index, access.instruction_offset, access.address
                ),
                description: format!(
                    "Memory read at 0x{:x} accesses data that was never written in this execution path. \
                     In on-chain programs, uninitialized data may contain stale values from previous \
                     transactions, leading to data confusion or privilege confusion.",
                    access.address,
                ),
                triggering_input: format_concrete_inputs(&state.concrete_values),
                path_constraints: state.path_constraints.iter().map(|c| c.expression.clone()).collect(),
                recommendation: "Zero-initialize all buffers before use. Validate account data freshness.".to_string(),
                fingerprint: String::new(),
                cwe: Some("CWE-908".to_string()),
                concolic_proof: Some(format!(
                    "Execution path reads addr 0x{:x} without prior write",
                    access.address
                )),
            });
        }

        findings
    }

    fn check_sbf_state(
        &self,
        state: &ConcolicState,
        entry: &SbfEntryPoint,
        _module: &SbfModule,
    ) -> Vec<WacanaFinding> {
        let mut findings = Vec::new();

        let mut written: std::collections::HashSet<u64> = std::collections::HashSet::new();
        for access in &state.memory_accesses {
            if access.is_write {
                written.insert(access.address);
            } else if !written.contains(&access.address) {
                findings.push(WacanaFinding {
                    category: VulnerabilityCategory::UninitializedData,
                    severity: WacanaSeverity::High,
                    location: format!("{}:+{} (read 0x{:x})", entry.name, access.instruction_offset, access.address),
                    description: format!(
                        "SBF read at 0x{:x} before any write. In Solana programs, this could \
                         expose data from a previous transaction's memory if the runtime doesn't zero-fill.",
                        access.address,
                    ),
                    triggering_input: format_concrete_inputs(&state.concrete_values),
                    path_constraints: state.path_constraints.iter().map(|c| c.expression.clone()).collect(),
                    recommendation: "Always initialize account data buffers before reads.".to_string(),
                    fingerprint: String::new(),
                    cwe: Some("CWE-908".to_string()),
                    concolic_proof: None,
                });
            }
        }

        findings
    }

    fn name(&self) -> &str {
        "UninitializedData"
    }
}

// ─── Reentrancy Pattern Detector ────────────────────────────────────────────

pub struct ReentrancyPatternDetector;

impl Default for ReentrancyPatternDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl ReentrancyPatternDetector {
    pub fn new() -> Self {
        Self
    }
}

impl VulnerabilityDetector for ReentrancyPatternDetector {
    fn check_wasm_state(
        &self,
        state: &ConcolicState,
        func: &WasmFunction,
        module: &WasmModule,
    ) -> Vec<WacanaFinding> {
        let mut findings = Vec::new();

        // Detect "write-after-external-call" pattern in instruction stream.
        // In WASM-on-Solana, an external call can re-enter the contract.
        let mut saw_external_call = false;
        let mut external_call_pc: usize = 0;

        for (pc, instr) in func.instructions.iter().enumerate() {
            match instr {
                WasmInstruction::Call { func_idx } => {
                    // Check if the callee is an import (external)
                    let is_import = module
                        .functions
                        .get(*func_idx as usize)
                        .map(|f| f.is_import)
                        .unwrap_or(false);
                    if is_import {
                        saw_external_call = true;
                        external_call_pc = pc;
                    }
                }
                WasmInstruction::I32Store { .. }
                | WasmInstruction::I64Store { .. }
                | WasmInstruction::I32Store8 { .. }
                | WasmInstruction::I32Store16 { .. }
                | WasmInstruction::I64Store8 { .. }
                | WasmInstruction::I64Store16 { .. }
                | WasmInstruction::I64Store32 { .. }
                    if saw_external_call =>
                {
                    findings.push(WacanaFinding {
                        category: VulnerabilityCategory::ReentrancyPattern,
                        severity: WacanaSeverity::Critical,
                        location: format!(
                            "func_{}:{} (state write after external call at pc {})",
                            func.index, pc, external_call_pc
                        ),
                        description: format!(
                            "State modification (memory store at pc {}) occurs after an external \
                             call (pc {}). If the external call re-enters this contract, the state \
                             modification can be exploited for reentrancy attacks. This is the \
                             classic \"Checks-Effects-Interactions\" violation.",
                            pc, external_call_pc,
                        ),
                        triggering_input: format_concrete_inputs(&state.concrete_values),
                        path_constraints: state.path_constraints.iter().map(|c| c.expression.clone()).collect(),
                        recommendation: "Move state modifications before external calls (CEI pattern). \
                            Add reentrancy guards.".to_string(),
                        fingerprint: String::new(),
                        cwe: Some("CWE-841".to_string()),
                        concolic_proof: Some(format!(
                            "Concolic path confirmed: external call at pc {} followed by store at pc {}",
                            external_call_pc, pc
                        )),
                    });
                    // Only report once per function
                    break;
                }
                _ => {}
            }
        }

        findings
    }

    fn check_sbf_state(
        &self,
        state: &ConcolicState,
        entry: &SbfEntryPoint,
        _module: &SbfModule,
    ) -> Vec<WacanaFinding> {
        let mut findings = Vec::new();

        // In SBF, reentrancy patterns show up as: call (syscall) followed by store
        let mut saw_call = false;
        let mut call_pc = 0usize;

        for (pc, instr) in entry.instructions.iter().enumerate() {
            let class = instr.opcode & 0x07;
            let op = instr.opcode & 0xf0;

            // BPF CALL instruction
            if class == 0x05 && op == 0x80 {
                saw_call = true;
                call_pc = pc;
            }

            // Memory store after call
            if saw_call && (class == 0x02 || class == 0x03) {
                findings.push(WacanaFinding {
                    category: VulnerabilityCategory::ReentrancyPattern,
                    severity: WacanaSeverity::High,
                    location: format!("{}:+{} (store after call at +{})", entry.name, pc, call_pc),
                    description: format!(
                        "SBF memory store at offset {} after call at offset {}. If the call invokes \
                         a CPI (cross-program invocation) that re-enters this program, the subsequent \
                         store may corrupt state.",
                        pc, call_pc,
                    ),
                    triggering_input: format_concrete_inputs(&state.concrete_values),
                    path_constraints: state.path_constraints.iter().map(|c| c.expression.clone()).collect(),
                    recommendation: "Perform all state writes before CPI calls. Use reentrancy guards.".to_string(),
                    fingerprint: String::new(),
                    cwe: Some("CWE-841".to_string()),
                    concolic_proof: None,
                });
                break;
            }
        }

        findings
    }

    fn name(&self) -> &str {
        "ReentrancyPattern"
    }
}

// ─── Integer Issue Detector ─────────────────────────────────────────────────

pub struct IntegerIssueDetector;

impl Default for IntegerIssueDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl IntegerIssueDetector {
    pub fn new() -> Self {
        Self
    }
}

impl VulnerabilityDetector for IntegerIssueDetector {
    fn check_wasm_state(
        &self,
        state: &ConcolicState,
        func: &WasmFunction,
        _module: &WasmModule,
    ) -> Vec<WacanaFinding> {
        let mut findings = Vec::new();

        for div in &state.divisions {
            if div.divisor == 0 {
                findings.push(WacanaFinding {
                    category: VulnerabilityCategory::DivisionByZero,
                    severity: WacanaSeverity::Critical,
                    location: format!(
                        "func_{}:{} (div by zero, {}-bit {}signed)",
                        func.index,
                        div.instruction_offset,
                        div.bit_width,
                        if div.is_signed { "" } else { "un" },
                    ),
                    description: format!(
                        "Division by zero reachable via concolic path. Dividend={}, divisor=0, \
                         {}-bit {}signed. In WASM, this causes a trap which halts the program \
                         and can be used for denial-of-service.",
                        div.dividend,
                        div.bit_width,
                        if div.is_signed { "" } else { "un" },
                    ),
                    triggering_input: format_concrete_inputs(&state.concrete_values),
                    path_constraints: state
                        .path_constraints
                        .iter()
                        .map(|c| c.expression.clone())
                        .collect(),
                    recommendation:
                        "Add explicit divisor != 0 checks before all division operations."
                            .to_string(),
                    fingerprint: String::new(),
                    cwe: Some("CWE-369".to_string()),
                    concolic_proof: Some(format!(
                        "Z3 produced inputs leading to div-by-zero at pc {}",
                        div.instruction_offset
                    )),
                });
            }

            // Check for signed division overflow (INT_MIN / -1)
            if div.is_signed {
                let min_val = if div.bit_width == 32 {
                    i32::MIN as i64
                } else {
                    i64::MIN
                };
                if div.dividend == min_val && div.divisor == -1 {
                    findings.push(WacanaFinding {
                        category: VulnerabilityCategory::IntegerOverflow,
                        severity: WacanaSeverity::High,
                        location: format!(
                            "func_{}:{} (signed overflow: MIN / -1)",
                            func.index, div.instruction_offset,
                        ),
                        description: format!(
                            "Signed division overflow: {} / -1 overflows {}-bit signed integer. \
                             In WASM, this is undefined behavior that may trap or produce incorrect results.",
                            div.dividend, div.bit_width,
                        ),
                        triggering_input: format_concrete_inputs(&state.concrete_values),
                        path_constraints: state.path_constraints.iter().map(|c| c.expression.clone()).collect(),
                        recommendation: "Check for INT_MIN / -1 before signed division.".to_string(),
                        fingerprint: String::new(),
                        cwe: Some("CWE-190".to_string()),
                        concolic_proof: Some(format!(
                            "Concolic execution found: dividend={}, divisor=-1",
                            div.dividend
                        )),
                    });
                }
            }
        }

        findings
    }

    fn check_sbf_state(
        &self,
        state: &ConcolicState,
        entry: &SbfEntryPoint,
        _module: &SbfModule,
    ) -> Vec<WacanaFinding> {
        let mut findings = Vec::new();

        for div in &state.divisions {
            if div.divisor == 0 {
                findings.push(WacanaFinding {
                    category: VulnerabilityCategory::DivisionByZero,
                    severity: WacanaSeverity::Critical,
                    location: format!("{}:+{} (div-by-zero)", entry.name, div.instruction_offset),
                    description: format!(
                        "SBF division by zero at offset {}. Dividend={}, {}-bit.",
                        div.instruction_offset, div.dividend, div.bit_width,
                    ),
                    triggering_input: format_concrete_inputs(&state.concrete_values),
                    path_constraints: state
                        .path_constraints
                        .iter()
                        .map(|c| c.expression.clone())
                        .collect(),
                    recommendation: "Guard all divisions with non-zero checks.".to_string(),
                    fingerprint: String::new(),
                    cwe: Some("CWE-369".to_string()),
                    concolic_proof: None,
                });
            }
        }

        findings
    }

    fn name(&self) -> &str {
        "IntegerIssues"
    }
}

// ─── Source-Level Pattern Scanner ────────────────────────────────────────────

/// Scan Rust source AST for patterns relevant to WASM/SBF data vulnerabilities.
pub fn scan_source_for_wasm_patterns(file: &syn::File, filename: &str) -> Vec<SourcePatternMatch> {
    let mut matches = Vec::new();

    for item in &file.items {
        if let syn::Item::Fn(func) = item {
            let fn_name = func.sig.ident.to_string();
            let source_text = quote::quote!(#func).to_string();

            // Pattern: Unchecked arithmetic on account data
            if source_text.contains("as u64")
                && (source_text.contains("amount")
                    || source_text.contains("balance")
                    || source_text.contains("lamports"))
                && !source_text.contains("checked_")
                && !source_text.contains("saturating_")
            {
                matches.push(SourcePatternMatch {
                    category: VulnerabilityCategory::IntegerOverflow,
                    severity: WacanaSeverity::High,
                    location: format!("{}::{}", filename, fn_name),
                    description: format!(
                        "Unchecked arithmetic cast on financial value in function `{}`. \
                         WASM/SBF programs must use checked_* or saturating_* to prevent overflow.",
                        fn_name,
                    ),
                    triggering_input: None,
                    path_constraints: Vec::new(),
                    recommendation: "Replace `as u64` with `.try_into().unwrap_or(0)` or use checked arithmetic.".to_string(),
                    cwe: Some("CWE-190".to_string()),
                    concolic_proof: None,
                });
            }

            // Pattern: Unvalidated account data deserialization
            if (source_text.contains("try_from_slice") || source_text.contains("unpack"))
                && !source_text.contains("validate")
                && !source_text.contains("is_initialized")
            {
                matches.push(SourcePatternMatch {
                    category: VulnerabilityCategory::UninitializedData,
                    severity: WacanaSeverity::High,
                    location: format!("{}::{}", filename, fn_name),
                    description: format!(
                        "Account data deserialization in `{}` without initialization check. \
                         An attacker may pass an uninitialized account to confuse program logic.",
                        fn_name,
                    ),
                    triggering_input: None,
                    path_constraints: Vec::new(),
                    recommendation: "Check `account.is_initialized` before deserialization.".to_string(),
                    cwe: Some("CWE-908".to_string()),
                    concolic_proof: None,
                });
            }

            // Pattern: Memory operations without bounds checking
            if (source_text.contains("unsafe") || source_text.contains("ptr::"))
                && (source_text.contains("copy")
                    || source_text.contains("write_bytes")
                    || source_text.contains("read_unaligned"))
                && !source_text.contains("len()")
                && !source_text.contains("bounds")
            {
                matches.push(SourcePatternMatch {
                    category: VulnerabilityCategory::MemorySafety,
                    severity: WacanaSeverity::Critical,
                    location: format!("{}::{}", filename, fn_name),
                    description: format!(
                        "Unsafe memory operation in `{}` without explicit bounds validation. \
                         In WASM/SBF, this can corrupt linear memory or account data.",
                        fn_name,
                    ),
                    triggering_input: None,
                    path_constraints: Vec::new(),
                    recommendation:
                        "Add explicit length/bounds checks before all unsafe memory operations."
                            .to_string(),
                    cwe: Some("CWE-787".to_string()),
                    concolic_proof: None,
                });
            }

            // Pattern: CPI without reentrancy guard
            if source_text.contains("invoke")
                && source_text.contains("program_id")
                && !source_text.contains("reentrancy")
                && !source_text.contains("is_locked")
                && !source_text.contains("guard")
            {
                // Check if there's a state write after the invoke
                if let Some(invoke_pos) = source_text.find("invoke") {
                    let after = &source_text[invoke_pos..];
                    if after.contains("serialize")
                        || after.contains("pack_into")
                        || after.contains("borrow_mut")
                    {
                        matches.push(SourcePatternMatch {
                            category: VulnerabilityCategory::ReentrancyPattern,
                            severity: WacanaSeverity::High,
                            location: format!("{}::{}", filename, fn_name),
                            description: format!(
                                "Cross-program invocation in `{}` followed by state serialization \
                                 without reentrancy guard. An attacker might re-enter during the CPI.",
                                fn_name,
                            ),
                            triggering_input: None,
                            path_constraints: Vec::new(),
                            recommendation: "Apply Checks-Effects-Interactions pattern. Serialize state before CPI.".to_string(),
                            cwe: Some("CWE-841".to_string()),
                            concolic_proof: None,
                        });
                    }
                }
            }

            // Pattern: External data used without validation
            if (source_text.contains("account_info") || source_text.contains("AccountInfo"))
                && source_text.contains("data")
                && (source_text.contains("memcpy") || source_text.contains("copy_from_slice"))
                && !source_text.contains("check")
                && !source_text.contains("validate")
            {
                matches.push(SourcePatternMatch {
                    category: VulnerabilityCategory::UncheckedExternalData,
                    severity: WacanaSeverity::High,
                    location: format!("{}::{}", filename, fn_name),
                    description: format!(
                        "External account data copied in `{}` without validation. \
                         On-chain data from external accounts must be sanitized before use.",
                        fn_name,
                    ),
                    triggering_input: None,
                    path_constraints: Vec::new(),
                    recommendation: "Validate all external account data before processing."
                        .to_string(),
                    cwe: Some("CWE-20".to_string()),
                    concolic_proof: None,
                });
            }
        }
    }

    matches
}

/// A source pattern match result.
pub struct SourcePatternMatch {
    pub category: VulnerabilityCategory,
    pub severity: WacanaSeverity,
    pub location: String,
    pub description: String,
    pub triggering_input: Option<String>,
    pub path_constraints: Vec<String>,
    pub recommendation: String,
    pub cwe: Option<String>,
    pub concolic_proof: Option<String>,
}

// ── Helper ──────────────────────────────────────────────────────────────────

fn format_concrete_inputs(values: &std::collections::HashMap<String, i64>) -> Option<String> {
    if values.is_empty() {
        return None;
    }
    let mut parts: Vec<String> = values.iter().map(|(k, v)| format!("{}={}", k, v)).collect();
    parts.sort();
    Some(parts.join(", "))
}
