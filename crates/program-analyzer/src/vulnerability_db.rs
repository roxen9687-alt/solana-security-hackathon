use crate::VulnerabilityFinding;

#[derive(Debug, Clone)]
pub struct VulnerabilityPattern {
    pub id: String,
    pub name: String,
    pub severity: u8,
    pub description: String,
    pub example: String,
    pub mitigation: String,
    pub checker: fn(&str) -> Option<VulnerabilityFinding>,
}

impl VulnerabilityPattern {
    pub fn new(
        id: &str,
        name: &str,
        severity: u8,
        checker: fn(&str) -> Option<VulnerabilityFinding>,
    ) -> Self {
        Self {
            id: id.to_string(),
            name: name.to_string(),
            severity,
            description: String::new(),
            example: String::new(),
            mitigation: String::new(),
            checker,
        }
    }
}

pub struct VulnerabilityDatabase {
    pub patterns: Vec<VulnerabilityPattern>,
}

impl VulnerabilityDatabase {
    pub fn load() -> Self {
        Self {
            patterns: get_default_patterns(),
        }
    }

    pub fn patterns(&self) -> &[VulnerabilityPattern] {
        &self.patterns
    }
}

pub fn get_default_patterns() -> Vec<VulnerabilityPattern> {
    vec![
        // ============ AUTHENTICATION & AUTHORIZATION (1.x) ============
        VulnerabilityPattern::new("SOL-001", "Missing Signer Check", 5, check_missing_signer),
        VulnerabilityPattern::new("SOL-002", "Integer Overflow", 4, check_integer_overflow),
        VulnerabilityPattern::new("SOL-003", "Missing Owner Check", 5, check_missing_owner),
        VulnerabilityPattern::new("SOL-004", "Type Cosplay", 5, check_type_cosplay),
        VulnerabilityPattern::new("SOL-005", "Arbitrary CPI", 5, check_arbitrary_cpi),
        VulnerabilityPattern::new(
            "SOL-006",
            "Duplicate Mutable Accounts",
            4,
            check_duplicate_accounts,
        ),
        VulnerabilityPattern::new("SOL-007", "Bump Seed Issues", 4, check_bump_seed),
        VulnerabilityPattern::new("SOL-008", "PDA Sharing", 4, check_pda_sharing),
        VulnerabilityPattern::new(
            "SOL-009",
            "Account Closing Issues",
            4,
            check_closing_accounts,
        ),
        VulnerabilityPattern::new("SOL-010", "Sysvar Address Issues", 3, check_sysvar_address),
        VulnerabilityPattern::new("SOL-011", "Initialization Issues", 4, check_initialization),
        VulnerabilityPattern::new(
            "SOL-012",
            "Account Data Mismatch",
            4,
            check_account_data_matching,
        ),
        // ============ ADDITIONAL PATTERNS (13-52) ============
        VulnerabilityPattern::new("SOL-013", "Missing Rent Exemption", 3, check_rent_exemption),
        VulnerabilityPattern::new(
            "SOL-014",
            "Unsafe Deserialization",
            4,
            check_unsafe_deserialization,
        ),
        VulnerabilityPattern::new("SOL-015", "Missing Program ID Check", 5, check_program_id),
        VulnerabilityPattern::new(
            "SOL-016",
            "Unchecked Return Value",
            4,
            check_unchecked_return,
        ),
        VulnerabilityPattern::new("SOL-017", "Reentrancy Risk", 5, check_reentrancy),
        VulnerabilityPattern::new("SOL-018", "Flash Loan Attack", 5, check_flash_loan),
        VulnerabilityPattern::new(
            "SOL-019",
            "Oracle Manipulation",
            5,
            check_oracle_manipulation,
        ),
        VulnerabilityPattern::new("SOL-020", "Price Stale Data", 4, check_stale_oracle),
        VulnerabilityPattern::new("SOL-021", "Mint Authority Issues", 5, check_mint_authority),
        VulnerabilityPattern::new(
            "SOL-022",
            "Freeze Authority Issues",
            4,
            check_freeze_authority,
        ),
        VulnerabilityPattern::new(
            "SOL-023",
            "Token Account Confusion",
            4,
            check_token_account_confusion,
        ),
        VulnerabilityPattern::new(
            "SOL-024",
            "Missing Token Validation",
            4,
            check_token_validation,
        ),
        VulnerabilityPattern::new("SOL-025", "Lamport Balance Drain", 5, check_lamport_drain),
        VulnerabilityPattern::new(
            "SOL-026",
            "Cross-Program Invocation Depth",
            3,
            check_cpi_depth,
        ),
        VulnerabilityPattern::new(
            "SOL-027",
            "Missing Seeds Validation",
            4,
            check_seeds_validation,
        ),
        VulnerabilityPattern::new(
            "SOL-028",
            "Account Resurrection",
            4,
            check_account_resurrection,
        ),
        VulnerabilityPattern::new(
            "SOL-029",
            "Missing Close Authority",
            4,
            check_close_authority,
        ),
        VulnerabilityPattern::new(
            "SOL-030",
            "Privilege Escalation",
            5,
            check_privilege_escalation,
        ),
        VulnerabilityPattern::new(
            "SOL-031",
            "Unauthorized Token Mint",
            5,
            check_unauthorized_mint,
        ),
        VulnerabilityPattern::new("SOL-032", "Missing Decimals Check", 3, check_decimals),
        VulnerabilityPattern::new("SOL-033", "Slippage Attack", 4, check_slippage),
        VulnerabilityPattern::new("SOL-034", "Sandwich Attack", 4, check_sandwich_attack),
        VulnerabilityPattern::new("SOL-035", "Front-Running", 4, check_frontrunning),
        VulnerabilityPattern::new(
            "SOL-036",
            "Missing Amount Validation",
            4,
            check_amount_validation,
        ),
        VulnerabilityPattern::new(
            "SOL-037",
            "Division Before Multiplication",
            3,
            check_div_before_mul,
        ),
        VulnerabilityPattern::new("SOL-038", "Precision Loss", 4, check_precision_loss),
        VulnerabilityPattern::new("SOL-039", "Rounding Errors", 3, check_rounding_errors),
        VulnerabilityPattern::new("SOL-040", "Missing Zero Check", 3, check_zero_check),
        VulnerabilityPattern::new(
            "SOL-041",
            "Unrestricted Transfer",
            5,
            check_unrestricted_transfer,
        ),
        VulnerabilityPattern::new(
            "SOL-042",
            "Missing Pause Mechanism",
            3,
            check_pause_mechanism,
        ),
        VulnerabilityPattern::new("SOL-043", "Hardcoded Address", 2, check_hardcoded_address),
        VulnerabilityPattern::new("SOL-044", "Missing Event Emission", 2, check_event_emission),
        VulnerabilityPattern::new("SOL-045", "Unsafe Math Operations", 4, check_unsafe_math),
        VulnerabilityPattern::new("SOL-046", "Time Manipulation", 3, check_time_manipulation),
        VulnerabilityPattern::new("SOL-047", "Missing Access Control", 5, check_access_control),
        VulnerabilityPattern::new("SOL-048", "Account Hijacking", 5, check_account_hijacking),
        VulnerabilityPattern::new("SOL-049", "LP Token Manipulation", 4, check_lp_manipulation),
        VulnerabilityPattern::new(
            "SOL-050",
            "Reward Calculation Error",
            4,
            check_reward_calculation,
        ),
        VulnerabilityPattern::new("SOL-051", "Missing Deadline Check", 3, check_deadline),
        VulnerabilityPattern::new("SOL-052", "Governance Attack", 4, check_governance_attack),
    ]
}

fn check_missing_signer(code: &str) -> Option<VulnerabilityFinding> {
    // Pattern 1: AccountInfo without Signer constraint (insecure)
    let has_account_info = code.contains("AccountInfo<");
    let has_signer = code.contains("Signer<")
        || code.contains("#[account(signer)]")
        || code.contains("is_signer");

    // Pattern 2: authority or admin without signer check
    let authority_pattern =
        code.contains("authority") || code.contains("admin") || code.contains("owner");

    if has_account_info && !has_signer && authority_pattern {
        return Some(VulnerabilityFinding {
            category: "Authentication".to_string(),
            vuln_type: "Missing Signer Check".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-001".to_string(),
            cwe: Some("CWE-287".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Authority account is not validated as a signer. Anyone can impersonate the authority.".to_string(),
            attack_scenario: "Attacker passes their own account as authority and executes privileged operations.".to_string(),
            real_world_incident: Some(crate::Incident { project: "Wormhole".to_string(), loss: "$320M".to_string(), date: "2022-02-02".to_string() }),
            secure_fix: "Add Signer<'info> constraint or validate is_signer".to_string(),
            prevention: "Always use Signer<'info> for authority accounts".to_string(),
        });
    }

    None
}

fn check_integer_overflow(code: &str) -> Option<VulnerabilityFinding> {
    // Check for unchecked arithmetic
    let has_arithmetic = code.contains('+') || code.contains('-') || code.contains('*');
    let has_checked = code.contains("checked_add")
        || code.contains("checked_sub")
        || code.contains("checked_mul")
        || code.contains("saturating_");

    if has_arithmetic && !has_checked && code.contains("u64") {
        return Some(VulnerabilityFinding {
            category: "Arithmetic".to_string(),
            vuln_type: "Integer Overflow/Underflow".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-002".to_string(),
            cwe: Some("CWE-190".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Unchecked arithmetic operations can cause overflow/underflow."
                .to_string(),
            attack_scenario:
                "Attacker provides values that cause arithmetic to wrap, manipulating balances."
                    .to_string(),
            real_world_incident: Some(crate::Incident {
                project: "DeFi Protocols".to_string(),
                loss: "Various".to_string(),
                date: "2021-2023".to_string(),
            }),
            secure_fix: "Use checked_add, checked_sub, checked_mul or require overflow-checks=true"
                .to_string(),
            prevention: "Always use checked arithmetic for financial calculations".to_string(),
        });
    }

    None
}

fn check_missing_owner(code: &str) -> Option<VulnerabilityFinding> {
    let has_account = code.contains("AccountInfo<") || code.contains("Account<");
    let has_owner_check =
        code.contains("owner ==") || code.contains(".owner") || code.contains("constraint = ");

    // If using raw AccountInfo without owner checks
    if has_account && !has_owner_check && code.contains("try_borrow_data") {
        return Some(VulnerabilityFinding {
            category: "Authorization".to_string(),
            vuln_type: "Missing Owner Check".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-003".to_string(),
            cwe: Some("CWE-285".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account owner is not validated. Attacker can pass fake accounts."
                .to_string(),
            attack_scenario:
                "Attacker creates fake account with malicious data and passes it as legitimate."
                    .to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Cashio".to_string(),
                loss: "$52M".to_string(),
                date: "2022-03-23".to_string(),
            }),
            secure_fix: "Validate account.owner == expected_program_id".to_string(),
            prevention: "Always verify account ownership before trusting data".to_string(),
        });
    }

    None
}

fn check_type_cosplay(code: &str) -> Option<VulnerabilityFinding> {
    // Check for #[derive(Accounts)] without discriminator
    let has_accounts = code.contains("#[derive(Accounts)]");
    let has_discriminator = code.contains("discriminator") || code.contains("DISCRIMINATOR");

    // Check for raw deserialization without type check
    let raw_deserialize = code.contains("try_from_slice") && !code.contains("discriminator");

    if (has_accounts && !has_discriminator) || raw_deserialize {
        return Some(VulnerabilityFinding {
            category: "Account Validation".to_string(),
            vuln_type: "Type Cosplay".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-004".to_string(),
            cwe: Some("CWE-843".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account type is not validated. Different account types can be confused.".to_string(),
            attack_scenario: "Attacker passes Account Type A where Type B is expected with matching field layout.".to_string(),
            real_world_incident: None,
            secure_fix: "Use Anchor's Account<T> which auto-validates discriminators".to_string(),
            prevention: "Always validate account discriminators/types".to_string(),
        });
    }

    None
}

fn check_arbitrary_cpi(code: &str) -> Option<VulnerabilityFinding> {
    // Check for invoke or invoke_signed without program validation
    let has_cpi = code.contains("invoke(") || code.contains("invoke_signed(");
    let validates_program = code.contains("program.key()")
        || code.contains("program_id ==")
        || code.contains("check_program_account");

    if has_cpi && !validates_program {
        return Some(VulnerabilityFinding {
            category: "CPI Security".to_string(),
            vuln_type: "Arbitrary CPI".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-005".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "CPI target program is not validated. Attacker can redirect calls."
                .to_string(),
            attack_scenario: "Attacker provides malicious program address and hijacks CPI call."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Validate program.key() == expected_program_id before CPI".to_string(),
            prevention: "Always whitelist and validate CPI target programs".to_string(),
        });
    }

    None
}

fn check_duplicate_accounts(code: &str) -> Option<VulnerabilityFinding> {
    // Check for multiple mut accounts that could be same
    let mut_count = code.matches("#[account(mut)]").count();
    let key_compare = code.contains(".key() !=") || code.contains("constraint = ");

    if mut_count >= 2 && !key_compare {
        return Some(VulnerabilityFinding {
            category: "Account Validation".to_string(),
            vuln_type: "Duplicate Mutable Accounts".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-006".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Multiple mutable accounts are not validated as distinct.".to_string(),
            attack_scenario: "Attacker passes same account for from and to, doubling balance."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Add constraint = from.key() != to.key()".to_string(),
            prevention: "Always validate account distinctness for mutable pairs".to_string(),
        });
    }

    None
}

fn check_bump_seed(code: &str) -> Option<VulnerabilityFinding> {
    // Check for PDA creation without canonical bump
    let has_find_program_address = code.contains("find_program_address");
    let has_bump_validation = code.contains("bump =") || code.contains("seeds::program");

    if has_find_program_address && !has_bump_validation {
        return Some(VulnerabilityFinding {
            category: "PDA Security".to_string(),
            vuln_type: "Bump Seed Issues".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-007".to_string(),
            cwe: Some("CWE-330".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "PDA bump seed is not canonicalized, allowing alternative valid PDAs."
                .to_string(),
            attack_scenario: "Attacker finds non-canonical bump to create parallel state."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Store and validate canonical bump from find_program_address".to_string(),
            prevention: "Always use and validate the canonical bump seed".to_string(),
        });
    }

    None
}

fn check_pda_sharing(code: &str) -> Option<VulnerabilityFinding> {
    // Check for shared PDAs without user-specific seeds
    let has_pda = code.contains("seeds = [");
    let has_user_seed = code.contains("user.key()")
        || code.contains("payer.key()")
        || code.contains("authority.key()");

    if has_pda && !has_user_seed && code.contains("pool") {
        return Some(VulnerabilityFinding {
            category: "PDA Security".to_string(),
            vuln_type: "PDA Sharing".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-008".to_string(),
            cwe: Some("CWE-284".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "PDA is shared across users without user-specific seeds.".to_string(),
            attack_scenario: "Users can interfere with each other's state through shared PDA."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Include user pubkey in PDA seeds".to_string(),
            prevention: "Per-user PDAs should include user key in seeds".to_string(),
        });
    }

    None
}

fn check_closing_accounts(code: &str) -> Option<VulnerabilityFinding> {
    // Check for account closing without proper cleanup
    let closes_account = code.contains("close =") || code.contains("set_lamports(0)");
    let clears_data =
        code.contains("data.fill(0)") || code.contains("CLOSED_ACCOUNT_DISCRIMINATOR");

    if closes_account && !clears_data {
        return Some(VulnerabilityFinding {
            category: "Account Management".to_string(),
            vuln_type: "Account Closing Issues".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-009".to_string(),
            cwe: Some("CWE-404".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account is closed without zeroing data, enabling revival attacks."
                .to_string(),
            attack_scenario: "Attacker revives closed account in same slot, reusing old data."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Zero account data before closing, use close discriminator".to_string(),
            prevention: "Always clear data and set discriminator when closing".to_string(),
        });
    }

    None
}

fn check_sysvar_address(code: &str) -> Option<VulnerabilityFinding> {
    // Check for sysvar usage without address validation
    let uses_sysvar =
        code.contains("Clock") || code.contains("Rent") || code.contains("SlotHashes");
    let validates_key = code.contains("sysvar::") || code.contains("SYSVAR_");

    if uses_sysvar && !validates_key && code.contains("AccountInfo") {
        return Some(VulnerabilityFinding {
            category: "Sysvar Security".to_string(),
            vuln_type: "Sysvar Address Issues".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-010".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Sysvar address is not validated, allowing fake sysvar injection."
                .to_string(),
            attack_scenario: "Attacker provides fake sysvar account with manipulated data."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Use Sysvar<Clock> or validate against sysvar ID constants".to_string(),
            prevention: "Always validate sysvar addresses".to_string(),
        });
    }

    None
}

fn check_initialization(code: &str) -> Option<VulnerabilityFinding> {
    // Check for reinitialization vulnerability
    let has_init = code.contains("init") || code.contains("initialize");
    let checks_initialized = code.contains("is_initialized")
        || code.contains("initialized ==")
        || code.contains("init,"); // Anchor's init constraint

    if has_init && !checks_initialized && !code.contains("#[account(init") {
        return Some(VulnerabilityFinding {
            category: "Initialization".to_string(),
            vuln_type: "Reinitialization Vulnerability".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-011".to_string(),
            cwe: Some("CWE-665".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account can be reinitialized, allowing state reset.".to_string(),
            attack_scenario: "Attacker reinitializes account to reset state and steal funds."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Check is_initialized flag or use Anchor's init constraint".to_string(),
            prevention: "Always prevent reinitialization".to_string(),
        });
    }

    None
}

fn check_account_data_matching(code: &str) -> Option<VulnerabilityFinding> {
    // Check for account relationship validation
    let has_multiple_accounts = code.contains("Account<")
        && (code.matches("Account<").count() >= 2 || code.matches("AccountInfo<").count() >= 2);
    let validates_relationships = code.contains("has_one =")
        || code.contains("constraint =")
        || code.contains("== vault.authority");

    if has_multiple_accounts
        && !validates_relationships
        && (code.contains("vault") || code.contains("pool") || code.contains("user"))
    {
        return Some(VulnerabilityFinding {
            category: "Account Validation".to_string(),
            vuln_type: "Account Data Mismatch".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-012".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account relationships are not validated.".to_string(),
            attack_scenario: "Attacker mixes accounts from different users/contexts.".to_string(),
            real_world_incident: None,
            secure_fix: "Add has_one = authority or constraint validations".to_string(),
            prevention: "Always validate account relationships".to_string(),
        });
    }

    None
}

// ============ NEW CHECKER FUNCTIONS (SOL-013 to SOL-052) ============

fn check_rent_exemption(code: &str) -> Option<VulnerabilityFinding> {
    let creates_account = code.contains("create_account") || code.contains("init,");
    let checks_rent = code.contains("rent_exempt") || code.contains("Rent::get");

    if creates_account && !checks_rent {
        return Some(VulnerabilityFinding {
            category: "Account Management".to_string(),
            vuln_type: "Missing Rent Exemption Check".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-013".to_string(),
            cwe: Some("CWE-754".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description:
                "Account creation without rent exemption check may cause account to be purged."
                    .to_string(),
            attack_scenario: "Account gets garbage collected after rent runs out.".to_string(),
            real_world_incident: None,
            secure_fix: "Ensure accounts are rent-exempt using Rent::get()?.minimum_balance()"
                .to_string(),
            prevention: "Always fund accounts to be rent-exempt".to_string(),
        });
    }
    None
}

fn check_unsafe_deserialization(code: &str) -> Option<VulnerabilityFinding> {
    let unsafe_deserialize = code.contains("try_from_slice_unchecked")
        || (code.contains("from_slice") && !code.contains("try_from"));

    if unsafe_deserialize {
        return Some(VulnerabilityFinding {
            category: "Data Validation".to_string(),
            vuln_type: "Unsafe Deserialization".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-014".to_string(),
            cwe: Some("CWE-502".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description:
                "Unsafe deserialization can read garbage data or cause undefined behavior."
                    .to_string(),
            attack_scenario:
                "Attacker provides malformed data that crashes or exploits the program.".to_string(),
            real_world_incident: None,
            secure_fix: "Use try_from_slice with proper error handling".to_string(),
            prevention: "Always validate data length and format before deserializing".to_string(),
        });
    }
    None
}

fn check_program_id(code: &str) -> Option<VulnerabilityFinding> {
    let has_cpi = code.contains("invoke") || code.contains("CpiContext");
    let checks_program = code.contains("program_id ==") || code.contains("key() ==");

    if has_cpi && !checks_program && code.contains("program:") {
        return Some(VulnerabilityFinding {
            category: "CPI Security".to_string(),
            vuln_type: "Missing Program ID Validation".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-015".to_string(),
            cwe: Some("CWE-345".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "CPI target program is not validated.".to_string(),
            attack_scenario: "Attacker substitutes malicious program for legitimate one."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Verify program_id matches expected address before CPI".to_string(),
            prevention: "Always validate CPI target addresses".to_string(),
        });
    }
    None
}

fn check_unchecked_return(code: &str) -> Option<VulnerabilityFinding> {
    let has_unwrap = code.contains(".unwrap()") && !code.contains("// safe:");
    let in_critical =
        code.contains("transfer") || code.contains("withdraw") || code.contains("deposit");

    if has_unwrap && in_critical {
        return Some(VulnerabilityFinding {
            category: "Error Handling".to_string(),
            vuln_type: "Unchecked Return Value".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-016".to_string(),
            cwe: Some("CWE-252".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Return value not checked, may panic on error.".to_string(),
            attack_scenario: "Transaction panics mid-execution leaving inconsistent state."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Use ? operator or proper error handling instead of unwrap()".to_string(),
            prevention: "Never use unwrap() on fallible operations in production".to_string(),
        });
    }
    None
}

fn check_reentrancy(code: &str) -> Option<VulnerabilityFinding> {
    let has_cpi = code.contains("invoke") || code.contains("CpiContext");
    let modifies_after = code.contains("borrow_mut") && code.contains("invoke");
    let has_guard = code.contains("ReentrancyGuard") || code.contains("is_locked");

    if has_cpi && modifies_after && !has_guard {
        return Some(VulnerabilityFinding {
            category: "Reentrancy".to_string(),
            vuln_type: "Cross-Program Reentrancy".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-017".to_string(),
            cwe: Some("CWE-841".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "State modification after CPI allows reentrancy attack.".to_string(),
            attack_scenario: "Attacker's program calls back before state is finalized.".to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Various DeFi".to_string(),
                loss: "$100M+".to_string(),
                date: "2021-2023".to_string(),
            }),
            secure_fix: "Update state BEFORE making CPI calls (Checks-Effects-Interactions)"
                .to_string(),
            prevention: "Follow CEI pattern, add reentrancy guards".to_string(),
        });
    }
    None
}

fn check_flash_loan(code: &str) -> Option<VulnerabilityFinding> {
    let is_flash = code.contains("flash_loan") || code.contains("FlashLoan");
    let checks_repay = code.contains("require!") || code.contains("assert!");

    if is_flash && !checks_repay {
        return Some(VulnerabilityFinding {
            category: "DeFi Security".to_string(),
            vuln_type: "Flash Loan Vulnerability".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-018".to_string(),
            cwe: Some("CWE-362".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Flash loan without proper repayment validation.".to_string(),
            attack_scenario: "Attacker manipulates state during flash loan and doesn't repay."
                .to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Multiple".to_string(),
                loss: "$200M+".to_string(),
                date: "2020-2023".to_string(),
            }),
            secure_fix: "Verify repayment + fee at end of flash loan instruction".to_string(),
            prevention: "Track pre/post balances and enforce invariants".to_string(),
        });
    }
    None
}

fn check_oracle_manipulation(code: &str) -> Option<VulnerabilityFinding> {
    let uses_oracle = code.contains("oracle")
        || code.contains("price_feed")
        || code.contains("Pyth")
        || code.contains("Switchboard");
    let single_source = !code.contains("twap") && !code.contains("median");
    let no_bounds = !code.contains("max_price") && !code.contains("min_price");

    if uses_oracle && single_source && no_bounds {
        return Some(VulnerabilityFinding {
            category: "Oracle Security".to_string(),
            vuln_type: "Oracle Price Manipulation".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-019".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Single oracle source without price bounds check.".to_string(),
            attack_scenario: "Attacker manipulates oracle price to drain funds.".to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Mango Markets".to_string(),
                loss: "$114M".to_string(),
                date: "2022-10-11".to_string(),
            }),
            secure_fix: "Use multiple oracles, TWAP, and price deviation checks".to_string(),
            prevention: "Implement circuit breakers for sudden price changes".to_string(),
        });
    }
    None
}

fn check_stale_oracle(code: &str) -> Option<VulnerabilityFinding> {
    let uses_oracle = code.contains("price") || code.contains("oracle");
    let checks_stale =
        code.contains("timestamp") || code.contains("stale") || code.contains("last_update");

    if uses_oracle && !checks_stale {
        return Some(VulnerabilityFinding {
            category: "Oracle Security".to_string(),
            vuln_type: "Stale Oracle Data".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-020".to_string(),
            cwe: Some("CWE-672".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Oracle data freshness not validated.".to_string(),
            attack_scenario: "Stale price data used for trading decisions.".to_string(),
            real_world_incident: None,
            secure_fix: "Check oracle.last_update_timestamp against current slot".to_string(),
            prevention: "Reject prices older than acceptable threshold".to_string(),
        });
    }
    None
}

fn check_mint_authority(code: &str) -> Option<VulnerabilityFinding> {
    let has_mint = code.contains("mint_to") || code.contains("MintTo");
    let checks_authority = code.contains("mint_authority") && code.contains("Signer");

    if has_mint && !checks_authority {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Unprotected Mint Authority".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-021".to_string(),
            cwe: Some("CWE-269".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Mint operation without proper authority validation.".to_string(),
            attack_scenario: "Attacker mints unlimited tokens.".to_string(),
            real_world_incident: None,
            secure_fix: "Validate mint authority is a signer".to_string(),
            prevention: "Use PDA as mint authority and validate seeds".to_string(),
        });
    }
    None
}

fn check_freeze_authority(code: &str) -> Option<VulnerabilityFinding> {
    let has_freeze = code.contains("freeze") || code.contains("Freeze");
    let is_checked = code.contains("freeze_authority") && code.contains("Signer");

    if has_freeze && !is_checked {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Freeze Authority Issues".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-022".to_string(),
            cwe: Some("CWE-269".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Freeze authority not properly validated.".to_string(),
            attack_scenario: "Attacker freezes user accounts.".to_string(),
            real_world_incident: None,
            secure_fix: "Validate freeze authority is authorized signer".to_string(),
            prevention: "Consider disabling freeze authority for DeFi tokens".to_string(),
        });
    }
    None
}

fn check_token_account_confusion(code: &str) -> Option<VulnerabilityFinding> {
    let has_token_accounts = code.contains("TokenAccount") || code.contains("token::Token");
    let validates_mint = code.contains("token_account.mint ==") || code.contains("constraint = ");

    if has_token_accounts && !validates_mint && code.contains("transfer") {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Token Account Confusion".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-023".to_string(),
            cwe: Some("CWE-843".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Token account mint not validated.".to_string(),
            attack_scenario: "Attacker substitutes token account for different mint.".to_string(),
            real_world_incident: None,
            secure_fix: "Add constraint: token_account.mint == expected_mint".to_string(),
            prevention: "Always validate token account mint matches expected".to_string(),
        });
    }
    None
}

fn check_token_validation(code: &str) -> Option<VulnerabilityFinding> {
    let has_token_op = code.contains("transfer") || code.contains("Transfer");
    let validates = code.contains("token_program") && code.contains("Program<");

    if has_token_op && !validates {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Missing Token Program Validation".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-024".to_string(),
            cwe: Some("CWE-345".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Token program not validated.".to_string(),
            attack_scenario: "Attacker passes fake token program.".to_string(),
            real_world_incident: None,
            secure_fix: "Use Program<'info, Token> to validate program ID".to_string(),
            prevention: "Always validate program accounts in CPI".to_string(),
        });
    }
    None
}

fn check_lamport_drain(code: &str) -> Option<VulnerabilityFinding> {
    let modifies_lamports = code.contains("lamports.borrow_mut") || code.contains(".lamports()");
    let unsafe_pattern = code.contains("**") && code.contains("lamports");

    if modifies_lamports && unsafe_pattern && !code.contains("rent_exempt") {
        return Some(VulnerabilityFinding {
            category: "Account Management".to_string(),
            vuln_type: "Lamport Balance Drain".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-025".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Unsafe lamport manipulation can drain account.".to_string(),
            attack_scenario: "Attacker drains lamports from program accounts.".to_string(),
            real_world_incident: None,
            secure_fix: "Validate lamport changes and maintain rent exemption".to_string(),
            prevention: "Use safe transfer patterns".to_string(),
        });
    }
    None
}

fn check_cpi_depth(code: &str) -> Option<VulnerabilityFinding> {
    let cpi_count = code.matches("invoke").count() + code.matches("CpiContext").count();

    if cpi_count > 3 {
        return Some(VulnerabilityFinding {
            category: "CPI Security".to_string(),
            vuln_type: "Deep CPI Chain".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-026".to_string(),
            cwe: Some("CWE-674".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Multiple nested CPI calls may hit depth limit.".to_string(),
            attack_scenario: "Transaction fails due to CPI depth limit.".to_string(),
            real_world_incident: None,
            secure_fix: "Reduce CPI chain depth, max is 4 levels".to_string(),
            prevention: "Design for minimal CPI depth".to_string(),
        });
    }
    None
}

fn check_seeds_validation(code: &str) -> Option<VulnerabilityFinding> {
    let has_pda = code.contains("find_program_address") || code.contains("seeds =");
    let user_input_seeds = code.contains("user.key()") || code.contains("ctx.accounts.");
    let validates = code.contains("bump =") || code.contains("bump,");

    if has_pda && user_input_seeds && !validates {
        return Some(VulnerabilityFinding {
            category: "PDA Security".to_string(),
            vuln_type: "Missing Seeds Validation".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-027".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "PDA seeds from user input not validated.".to_string(),
            attack_scenario: "Attacker provides malicious seeds to access other PDAs.".to_string(),
            real_world_incident: None,
            secure_fix: "Store bump seed and validate on each access".to_string(),
            prevention: "Always verify PDA derivation".to_string(),
        });
    }
    None
}

fn check_account_resurrection(code: &str) -> Option<VulnerabilityFinding> {
    let closes_account = code.contains("close =") || code.contains("close_account");
    let clears_data = code.contains("fill(0)") || code.contains("set_lamports(0)");

    if closes_account && !clears_data {
        return Some(VulnerabilityFinding {
            category: "Account Management".to_string(),
            vuln_type: "Account Resurrection".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-028".to_string(),
            cwe: Some("CWE-672".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Closed account data not cleared, can be resurrected.".to_string(),
            attack_scenario: "Attacker resurrects closed account in same transaction.".to_string(),
            real_world_incident: None,
            secure_fix: "Zero out account data before transfer lamports".to_string(),
            prevention: "Always clear data and use close constraint".to_string(),
        });
    }
    None
}

fn check_close_authority(code: &str) -> Option<VulnerabilityFinding> {
    let closes = code.contains("close =") || code.contains("close_account");
    let checks_auth = code.contains("authority") && code.contains("Signer");

    if closes && !checks_auth {
        return Some(VulnerabilityFinding {
            category: "Authorization".to_string(),
            vuln_type: "Missing Close Authority".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-029".to_string(),
            cwe: Some("CWE-285".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account close without authority check.".to_string(),
            attack_scenario: "Anyone can close accounts and steal lamports.".to_string(),
            real_world_incident: None,
            secure_fix: "Require authorized signer for close operations".to_string(),
            prevention: "Always validate close authority".to_string(),
        });
    }
    None
}

fn check_privilege_escalation(code: &str) -> Option<VulnerabilityFinding> {
    let modifies_auth = code.contains("authority =") || code.contains("set_authority");
    let requires_current = code.contains("current_authority") && code.contains("Signer");

    if modifies_auth && !requires_current {
        return Some(VulnerabilityFinding {
            category: "Authorization".to_string(),
            vuln_type: "Privilege Escalation".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-030".to_string(),
            cwe: Some("CWE-269".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Authority can be changed without proper validation.".to_string(),
            attack_scenario: "Attacker changes authority to themselves.".to_string(),
            real_world_incident: None,
            secure_fix: "Require current authority signature to change authority".to_string(),
            prevention: "Implement two-step authority transfer".to_string(),
        });
    }
    None
}

fn check_unauthorized_mint(code: &str) -> Option<VulnerabilityFinding> {
    let mints = code.contains("mint_to");
    let has_cap = code.contains("max_supply") || code.contains("cap");

    if mints && !has_cap {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Unlimited Token Mint".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-031".to_string(),
            cwe: Some("CWE-269".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Token minting has no supply cap.".to_string(),
            attack_scenario: "Mint authority prints unlimited tokens.".to_string(),
            real_world_incident: None,
            secure_fix: "Implement max supply check before minting".to_string(),
            prevention: "Define and enforce token supply cap".to_string(),
        });
    }
    None
}

fn check_decimals(code: &str) -> Option<VulnerabilityFinding> {
    let has_amounts = code.contains("amount") && code.contains("transfer");
    let checks_decimals = code.contains("decimals") || code.contains("10.pow");

    if has_amounts && !checks_decimals && code.contains("u64") {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Missing Decimals Validation".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-032".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Token decimals not validated in calculations.".to_string(),
            attack_scenario: "Wrong decimals cause incorrect value calculations.".to_string(),
            real_world_incident: None,
            secure_fix: "Normalize amounts based on token decimals".to_string(),
            prevention: "Always account for token decimals".to_string(),
        });
    }
    None
}

fn check_slippage(code: &str) -> Option<VulnerabilityFinding> {
    let is_swap = code.contains("swap") || code.contains("exchange");
    let has_slippage =
        code.contains("slippage") || code.contains("min_amount") || code.contains("max_amount");

    if is_swap && !has_slippage {
        return Some(VulnerabilityFinding {
            category: "DeFi Security".to_string(),
            vuln_type: "Missing Slippage Protection".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-033".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Swap operation without slippage protection.".to_string(),
            attack_scenario: "MEV bots sandwich the transaction for profit.".to_string(),
            real_world_incident: None,
            secure_fix: "Add min_amount_out parameter and validate".to_string(),
            prevention: "Always implement slippage tolerance".to_string(),
        });
    }
    None
}

fn check_sandwich_attack(code: &str) -> Option<VulnerabilityFinding> {
    let is_amm = code.contains("pool") && (code.contains("swap") || code.contains("add_liquidity"));
    let has_protection = code.contains("deadline") || code.contains("slippage");

    if is_amm && !has_protection {
        return Some(VulnerabilityFinding {
            category: "MEV Protection".to_string(),
            vuln_type: "Sandwich Attack Vulnerability".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-034".to_string(),
            cwe: Some("CWE-362".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "AMM operation vulnerable to sandwich attacks.".to_string(),
            attack_scenario: "Attacker front-runs and back-runs user transaction.".to_string(),
            real_world_incident: None,
            secure_fix: "Add slippage and deadline parameters".to_string(),
            prevention: "Implement MEV protection mechanisms".to_string(),
        });
    }
    None
}

fn check_frontrunning(code: &str) -> Option<VulnerabilityFinding> {
    let sensitive_op = code.contains("bid") || code.contains("commit") || code.contains("reveal");
    let has_commitment = code.contains("hash") || code.contains("commit_reveal");

    if sensitive_op && !has_commitment {
        return Some(VulnerabilityFinding {
            category: "MEV Protection".to_string(),
            vuln_type: "Front-Running Vulnerability".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-035".to_string(),
            cwe: Some("CWE-362".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Operation can be front-run by observing mempool.".to_string(),
            attack_scenario: "Attacker sees pending transaction and front-runs.".to_string(),
            real_world_incident: None,
            secure_fix: "Use commit-reveal scheme".to_string(),
            prevention: "Hide sensitive data until execution".to_string(),
        });
    }
    None
}

fn check_amount_validation(code: &str) -> Option<VulnerabilityFinding> {
    let has_transfer = code.contains("transfer") || code.contains("withdraw");
    let validates =
        code.contains("amount >") || code.contains("amount >=") || code.contains("require!");

    if has_transfer && !validates && code.contains("amount:") {
        return Some(VulnerabilityFinding {
            category: "Input Validation".to_string(),
            vuln_type: "Missing Amount Validation".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-036".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Transfer amount not validated.".to_string(),
            attack_scenario: "Zero or excessive amounts may cause issues.".to_string(),
            real_world_incident: None,
            secure_fix: "Validate amount > 0 and <= balance".to_string(),
            prevention: "Always validate user input amounts".to_string(),
        });
    }
    None
}

fn check_div_before_mul(code: &str) -> Option<VulnerabilityFinding> {
    // Simple heuristic: division followed by multiplication
    let has_div_mul = code.contains("/ ") && code.contains(" *");
    let div_pos = code.find('/');
    let mul_pos = code.find('*');

    if let (Some(d), Some(m)) = (div_pos, mul_pos) {
        if d < m && has_div_mul {
            return Some(VulnerabilityFinding {
                category: "Arithmetic".to_string(),
                vuln_type: "Division Before Multiplication".to_string(),
                severity: 3,
                severity_label: "MEDIUM".to_string(),
                id: "SOL-037".to_string(),
                cwe: Some("CWE-682".to_string()),
                location: String::new(),
                function_name: String::new(),
                line_number: 0,
                vulnerable_code: String::new(),
                description: "Division before multiplication causes precision loss.".to_string(),
                attack_scenario: "Small amounts get truncated to zero.".to_string(),
                real_world_incident: None,
                secure_fix: "Multiply before dividing: (a * b) / c".to_string(),
                prevention: "Always multiply before dividing".to_string(),
            });
        }
    }
    None
}

fn check_precision_loss(code: &str) -> Option<VulnerabilityFinding> {
    let has_division = code.contains('/') && code.contains("u64");
    let uses_fixed = code.contains("Decimal") || code.contains("U256") || code.contains("u128");

    if has_division && !uses_fixed && code.contains("rate") {
        return Some(VulnerabilityFinding {
            category: "Arithmetic".to_string(),
            vuln_type: "Precision Loss".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-038".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Integer division causes precision loss in rates.".to_string(),
            attack_scenario: "Attacker exploits rounding for profit.".to_string(),
            real_world_incident: None,
            secure_fix: "Use higher precision types (u128) for intermediate calcs".to_string(),
            prevention: "Scale values before division".to_string(),
        });
    }
    None
}

fn check_rounding_errors(code: &str) -> Option<VulnerabilityFinding> {
    let has_shares = code.contains("shares") || code.contains("pool_tokens");
    let has_division = code.contains('/');
    let rounds_correctly = code.contains("round_up") || code.contains("ceil");

    if has_shares && has_division && !rounds_correctly {
        return Some(VulnerabilityFinding {
            category: "Arithmetic".to_string(),
            vuln_type: "Rounding Direction Error".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-039".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Rounding direction may favor attacker.".to_string(),
            attack_scenario: "Attacker profits from repeated rounding errors.".to_string(),
            real_world_incident: None,
            secure_fix: "Round in favor of protocol, not user".to_string(),
            prevention: "Always round against the user in financial ops".to_string(),
        });
    }
    None
}

fn check_zero_check(code: &str) -> Option<VulnerabilityFinding> {
    let has_division = code.contains('/');
    let checks_zero = code.contains("!= 0") || code.contains("> 0") || code.contains("require!(");

    if has_division && !checks_zero && code.contains("divisor") {
        return Some(VulnerabilityFinding {
            category: "Arithmetic".to_string(),
            vuln_type: "Missing Zero Check".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-040".to_string(),
            cwe: Some("CWE-369".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Division without zero check can panic.".to_string(),
            attack_scenario: "Attacker triggers panic with zero divisor.".to_string(),
            real_world_incident: None,
            secure_fix: "Check divisor != 0 before division".to_string(),
            prevention: "Always validate divisors".to_string(),
        });
    }
    None
}

fn check_unrestricted_transfer(code: &str) -> Option<VulnerabilityFinding> {
    let has_transfer = code.contains("transfer(");
    let has_any_check =
        code.contains("Signer") || code.contains("authority") || code.contains("require!");

    if has_transfer && !has_any_check {
        return Some(VulnerabilityFinding {
            category: "Authorization".to_string(),
            vuln_type: "Unrestricted Transfer".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-041".to_string(),
            cwe: Some("CWE-285".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Transfer operation without access control.".to_string(),
            attack_scenario: "Anyone can trigger transfers.".to_string(),
            real_world_incident: None,
            secure_fix: "Require authorized signer for transfers".to_string(),
            prevention: "Always protect sensitive operations".to_string(),
        });
    }
    None
}

fn check_pause_mechanism(code: &str) -> Option<VulnerabilityFinding> {
    let is_defi = code.contains("swap") || code.contains("deposit") || code.contains("withdraw");
    let has_pause =
        code.contains("paused") || code.contains("is_active") || code.contains("emergency");

    if is_defi && !has_pause {
        return Some(VulnerabilityFinding {
            category: "Protocol Safety".to_string(),
            vuln_type: "Missing Pause Mechanism".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-042".to_string(),
            cwe: Some("CWE-754".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "No emergency pause mechanism.".to_string(),
            attack_scenario: "Cannot stop exploit in progress.".to_string(),
            real_world_incident: None,
            secure_fix: "Implement pausable pattern with admin control".to_string(),
            prevention: "Always have emergency controls".to_string(),
        });
    }
    None
}

fn check_hardcoded_address(code: &str) -> Option<VulnerabilityFinding> {
    // Check for hardcoded base58 pubkeys (32 chars of base58)
    let _has_hardcoded =
        code.len() > 44 && code.chars().filter(|c| c.is_alphanumeric()).count() > 40;

    if code.contains("\"")
        && (code.contains("11111") || code.contains("Token"))
        && !code.contains("system_program")
    {
        return Some(VulnerabilityFinding {
            category: "Code Quality".to_string(),
            vuln_type: "Hardcoded Address".to_string(),
            severity: 2,
            severity_label: "LOW".to_string(),
            id: "SOL-043".to_string(),
            cwe: Some("CWE-798".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Hardcoded address reduces flexibility.".to_string(),
            attack_scenario: "Cannot upgrade to new address if needed.".to_string(),
            real_world_incident: None,
            secure_fix: "Use configurable addresses or PDAs".to_string(),
            prevention: "Parameterize addresses where possible".to_string(),
        });
    }
    None
}

fn check_event_emission(code: &str) -> Option<VulnerabilityFinding> {
    let has_state_change =
        code.contains("transfer") || code.contains("deposit") || code.contains("withdraw");
    let emits_event = code.contains("emit!") || code.contains("msg!") || code.contains("Event");

    if has_state_change && !emits_event {
        return Some(VulnerabilityFinding {
            category: "Observability".to_string(),
            vuln_type: "Missing Event Emission".to_string(),
            severity: 2,
            severity_label: "LOW".to_string(),
            id: "SOL-044".to_string(),
            cwe: None,
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "State changes not logged.".to_string(),
            attack_scenario: "Cannot track or audit protocol activity.".to_string(),
            real_world_incident: None,
            secure_fix: "Emit events for all significant state changes".to_string(),
            prevention: "Always emit events for important operations".to_string(),
        });
    }
    None
}

fn check_unsafe_math(code: &str) -> Option<VulnerabilityFinding> {
    let has_exp = code.contains("**") || code.contains("pow(");
    let has_protection = code.contains("checked_pow") || code.contains("saturating");

    if has_exp && !has_protection {
        return Some(VulnerabilityFinding {
            category: "Arithmetic".to_string(),
            vuln_type: "Unsafe Exponentiation".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-045".to_string(),
            cwe: Some("CWE-190".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Exponentiation without overflow protection.".to_string(),
            attack_scenario: "Large exponents cause overflow.".to_string(),
            real_world_incident: None,
            secure_fix: "Use checked_pow or validate exponent bounds".to_string(),
            prevention: "Bound exponential calculations".to_string(),
        });
    }
    None
}

fn check_time_manipulation(code: &str) -> Option<VulnerabilityFinding> {
    let uses_clock = code.contains("Clock::get") || code.contains("unix_timestamp");
    let is_critical = code.contains("lock") || code.contains("vest") || code.contains("deadline");
    let has_buffer = code.contains("buffer") || code.contains("tolerance");

    if uses_clock && is_critical && !has_buffer {
        return Some(VulnerabilityFinding {
            category: "Time Safety".to_string(),
            vuln_type: "Time Manipulation Risk".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-046".to_string(),
            cwe: Some("CWE-367".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Time-sensitive operation without tolerance.".to_string(),
            attack_scenario: "Validator manipulates slot time for advantage.".to_string(),
            real_world_incident: None,
            secure_fix: "Add time buffer for critical operations".to_string(),
            prevention: "Don't rely on exact timestamps".to_string(),
        });
    }
    None
}

fn check_access_control(code: &str) -> Option<VulnerabilityFinding> {
    let modifies_state = code.contains("borrow_mut") || code.contains("set_");
    let has_auth = code.contains("authority") || code.contains("admin") || code.contains("owner");
    let validates = code.contains("Signer<") || code.contains("require!");

    if modifies_state && has_auth && !validates {
        return Some(VulnerabilityFinding {
            category: "Authorization".to_string(),
            vuln_type: "Missing Access Control".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-047".to_string(),
            cwe: Some("CWE-862".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "State modification without access control.".to_string(),
            attack_scenario: "Anyone can modify protected state.".to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Wormhole".to_string(),
                loss: "$320M".to_string(),
                date: "2022-02-02".to_string(),
            }),
            secure_fix: "Validate caller is authorized signer".to_string(),
            prevention: "Always check authorization before state changes".to_string(),
        });
    }
    None
}

fn check_account_hijacking(code: &str) -> Option<VulnerabilityFinding> {
    let inits_account = code.contains("init,") || code.contains("create_account");
    let user_provided_key = code.contains("user.key()") || code.contains("payer.key()");
    let validates_owner = code.contains("seeds =") || code.contains("owner ==");

    if inits_account && user_provided_key && !validates_owner {
        return Some(VulnerabilityFinding {
            category: "Account Security".to_string(),
            vuln_type: "Account Hijacking".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-048".to_string(),
            cwe: Some("CWE-287".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account initialization allows hijacking.".to_string(),
            attack_scenario: "Attacker creates account for victim's address.".to_string(),
            real_world_incident: None,
            secure_fix: "Derive accounts from user's pubkey with PDA".to_string(),
            prevention: "Use deterministic account addresses".to_string(),
        });
    }
    None
}

fn check_lp_manipulation(code: &str) -> Option<VulnerabilityFinding> {
    let is_lp = code.contains("lp_token") || code.contains("pool_token") || code.contains("shares");
    let has_invariant = code.contains("k_before")
        || code.contains("invariant")
        || code.contains("constant_product");

    if is_lp && !has_invariant && code.contains("mint") {
        return Some(VulnerabilityFinding {
            category: "DeFi Security".to_string(),
            vuln_type: "LP Token Manipulation".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-049".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "LP token calculation may be manipulated.".to_string(),
            attack_scenario: "First depositor attack or ratio manipulation.".to_string(),
            real_world_incident: None,
            secure_fix: "Check invariants before and after LP operations".to_string(),
            prevention: "Initialize pools with minimum liquidity".to_string(),
        });
    }
    None
}

fn check_reward_calculation(code: &str) -> Option<VulnerabilityFinding> {
    let is_staking = code.contains("reward") || code.contains("stake");
    let time_based = code.contains("timestamp") || code.contains("duration");
    let validates = code.contains("elapsed") && code.contains("checked");

    if is_staking && time_based && !validates {
        return Some(VulnerabilityFinding {
            category: "DeFi Security".to_string(),
            vuln_type: "Reward Calculation Error".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-050".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Reward calculation may have timing issues.".to_string(),
            attack_scenario: "Attacker games reward timing for extra rewards.".to_string(),
            real_world_incident: None,
            secure_fix: "Use checked arithmetic for reward calculations".to_string(),
            prevention: "Validate time deltas and handle edge cases".to_string(),
        });
    }
    None
}

fn check_deadline(code: &str) -> Option<VulnerabilityFinding> {
    let is_swap = code.contains("swap") || code.contains("trade");
    let has_deadline = code.contains("deadline") || code.contains("expires");

    if is_swap && !has_deadline {
        return Some(VulnerabilityFinding {
            category: "Transaction Safety".to_string(),
            vuln_type: "Missing Deadline Check".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-051".to_string(),
            cwe: Some("CWE-367".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Transaction has no expiry deadline.".to_string(),
            attack_scenario: "Stale transactions execute at unfavorable prices.".to_string(),
            real_world_incident: None,
            secure_fix: "Add deadline parameter and validate".to_string(),
            prevention: "All user-facing txs should have deadlines".to_string(),
        });
    }
    None
}

fn check_governance_attack(code: &str) -> Option<VulnerabilityFinding> {
    let is_gov = code.contains("proposal") || code.contains("vote") || code.contains("governance");
    let has_timelock = code.contains("timelock") || code.contains("delay");
    let has_quorum = code.contains("quorum") || code.contains("threshold");

    if is_gov && (!has_timelock || !has_quorum) {
        return Some(VulnerabilityFinding {
            category: "Governance".to_string(),
            vuln_type: "Governance Attack".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-052".to_string(),
            cwe: Some("CWE-284".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Governance lacks required safeguards.".to_string(),
            attack_scenario: "Flash loan governance attack.".to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Beanstalk".to_string(),
                loss: "$182M".to_string(),
                date: "2022-04-17".to_string(),
            }),
            secure_fix: "Implement timelock and voting snapshot".to_string(),
            prevention: "Use battle-tested governance patterns".to_string(),
        });
    }
    None
}
